"use strict";exports.id=504,exports.ids=[504],exports.modules={30504:(a,b,c)=>{c.d(b,{w4:()=>r,Pc:()=>x}),c(84895);var d=c(16885);let e=d.Ik({workflowId:d.Yj().min(1),triggerData:d.g1(d.L5()),context:d.Ik({orgId:d.Yj().min(1),userId:d.Yj().optional(),sourceEvent:d.Yj().optional(),correlationId:d.Yj().optional(),metadata:d.g1(d.L5()).optional()}),options:d.Ik({timeout:d.ai().positive().optional(),retries:d.ai().int().min(0).max(10).optional(),async:d.zM().optional(),callbackUrl:d.Yj().url().optional(),headers:d.g1(d.Yj()).optional(),priority:d.ai().int().min(1).max(5).optional()}).optional()}),f=d.Ik({webhookUrl:d.Yj().url(),payload:d.g1(d.L5()),options:d.Ik({timeout:d.ai().positive().optional(),retries:d.ai().int().min(0).max(10).optional(),headers:d.g1(d.Yj()).optional(),method:d.k5(["GET","POST","PUT","PATCH"]).optional()}).optional()});class g extends Error{constructor(a,b,c=!1,d,e){super(a),this.code=b,this.retryable=c,this.statusCode=d,this.originalError=e,this.name="AutomationError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,g)}}class h extends g{constructor(a,b){super(`Rate limit exceeded for workflow ${a}`,"RATE_LIMIT_EXCEEDED",!0,429),this.retryAfterMs=b,this.name="RateLimitExceededError"}}class i extends g{constructor(a){super(`Workflow not found: ${a}`,"WORKFLOW_NOT_FOUND",!1,404),this.name="WorkflowNotFoundError"}}class j extends g{constructor(a,b,c=!1,d){super(a,"WEBHOOK_REQUEST_FAILED",c,b,d),this.name="WebhookRequestError"}}class k extends g{constructor(a,b){super(`Execution timed out after ${b}ms for workflow ${a}`,"EXECUTION_TIMEOUT",!0,408),this.name="ExecutionTimeoutError"}}let l="undefined"!=typeof process&&!1;function m(){return"undefined"!=typeof crypto&&"function"==typeof crypto.randomUUID?crypto.randomUUID():"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,a=>{let b=16*Math.random()|0;return("x"===a?b:3&b|8).toString(16)})}function n(a){return new Promise(b=>setTimeout(b,a))}class o{constructor(a,b){this.limitPerWindow=a,this.globalLimit=b,this.entries=new Map,this.windowMs=6e4}isAllowed(a){let b=Date.now();this.cleanup(b);let c=this.entries.get("__global__")??{timestamps:[],lastReset:b};if(c.timestamps.length>=this.globalLimit)return{allowed:!1,retryAfterMs:Math.max(0,c.timestamps[0]+this.windowMs-b)};let d=this.entries.get(a)??{timestamps:[],lastReset:b};return d.timestamps.length>=this.limitPerWindow?{allowed:!1,retryAfterMs:Math.max(0,d.timestamps[0]+this.windowMs-b)}:{allowed:!0}}record(a){let b=Date.now(),c=this.entries.get("__global__")??{timestamps:[],lastReset:b};c.timestamps.push(b),this.entries.set("__global__",c);let d=this.entries.get(a)??{timestamps:[],lastReset:b};d.timestamps.push(b),this.entries.set(a,d)}cleanup(a){let b=a-this.windowMs;for(let[a,c]of this.entries.entries())c.timestamps=c.timestamps.filter(a=>a>b),0===c.timestamps.length&&this.entries.delete(a)}getStats(a){this.cleanup(Date.now());let b=this.entries.get(a)??{timestamps:[],lastReset:Date.now()};return{requestsInWindow:b.timestamps.length,remaining:Math.max(0,this.limitPerWindow-b.timestamps.length)}}}class p{add(a){this.entries.unshift(a),this.entries.length>this.maxEntries&&(this.entries=this.entries.slice(0,this.maxEntries))}update(a,b){let c=this.entries.find(b=>b.id===a);c&&Object.assign(c,b)}get(a){return this.entries.find(b=>b.id===a)}getRecent(a=100){return this.entries.slice(0,a)}getByWorkflow(a,b=50){return this.entries.filter(b=>b.workflowId===a).slice(0,b)}constructor(){this.entries=[],this.maxEntries=1e3}}class q{constructor(a){this.scheduledAutomations=new Map,this.workflowCache=new Map,this.stats={totalTriggers:0,successfulTriggers:0,failedTriggers:0,totalWebhookCalls:0,averageExecutionTimeMs:0},this.config={n8nBaseUrl:a.n8nBaseUrl.replace(/\/$/,""),n8nApiKey:a.n8nApiKey??"",defaultTimeout:a.defaultTimeout??3e4,defaultRetries:a.defaultRetries??3,rateLimitPerWorkflow:a.rateLimitPerWorkflow??30,globalRateLimit:a.globalRateLimit??100,logger:a.logger??function(a){return{debug:(b,c)=>{l&&console.debug(`[${a}] ${b}`,c??"")},info:(b,c)=>{console.info(`[${a}] ${b}`,c??"")},warn:(b,c)=>{console.warn(`[${a}] ${b}`,c??"")},error:(b,c,d)=>{console.error(`[${a}] ${b}`,c,d??"")}}}("AutomationTrigger"),debug:a.debug??!1},this.logger=this.config.logger,this.rateLimiter=new o(this.config.rateLimitPerWorkflow,this.config.globalRateLimit),this.executionLog=new p,this.logger.info("AutomationTrigger initialized",{n8nBaseUrl:this.config.n8nBaseUrl,defaultTimeout:this.config.defaultTimeout,rateLimitPerWorkflow:this.config.rateLimitPerWorkflow})}async trigger(a,b,c,d){let f=Date.now(),j=m(),k=c?.correlationId??m();this.logger.info(`Triggering workflow ${a}`,{executionId:j,correlationId:k,async:d?.async});let l=e.safeParse({workflowId:a,triggerData:b,context:c??{orgId:"default"},options:d});if(!l.success)return this.createFailedResult(a,f,"VALIDATION_ERROR",`Invalid trigger payload: ${l.error.message}`,!1);let n=this.rateLimiter.isAllowed(a);if(!n.allowed)throw this.logger.warn(`Rate limit exceeded for workflow ${a}`,{retryAfterMs:n.retryAfterMs}),new h(a,n.retryAfterMs);this.rateLimiter.record(a),this.executionLog.add({id:j,workflowId:a,status:"pending",triggeredAt:new Date,context:c});try{let c,e=await this.getWorkflowDetails(a);if(!e)throw new i(a);if(!e.isActive)return this.createFailedResult(a,f,"WORKFLOW_INACTIVE",`Workflow ${a} is not active`,!1);return c=e.webhookUrl?await this.executeWebhookTrigger(e.webhookUrl,b,j,a,f,d):await this.executeApiTrigger(a,b,j,f,d),this.executionLog.update(j,{status:c.status,completedAt:c.completedAt,executionTimeMs:c.executionTimeMs,error:c.error}),this.updateStats(c),c}catch(b){let a=b instanceof Error?b.message:String(b);throw b instanceof g&&b.retryable,this.executionLog.update(j,{status:"failed",completedAt:new Date,executionTimeMs:Date.now()-f,error:a}),this.stats.failedTriggers++,b}}async triggerByName(a,b,c,d){this.logger.info(`Looking up workflow by name: ${a}`,{orgId:c});let e=(await this.listAvailableWorkflows(c)).find(b=>b.name.toLowerCase()===a.toLowerCase());if(!e)throw new i(`name:${a}`);return this.trigger(e.id,b,{orgId:c},d)}async triggerWebhook(a,b,c){let d,e=Date.now(),g=m(),i=f.safeParse({webhookUrl:a,payload:b,options:c});if(!i.success)return{success:!1,workflowId:"webhook",status:"failed",executionTimeMs:Date.now()-e,error:`Invalid webhook request: ${i.error.message}`,errorCode:"VALIDATION_ERROR",retryable:!1,triggeredAt:new Date,statusCode:400};let j=this.rateLimiter.isAllowed("__webhooks__");if(!j.allowed)throw new h("__webhooks__",j.retryAfterMs);this.rateLimiter.record("__webhooks__"),this.stats.totalWebhookCalls++;let k=c?.timeout??this.config.defaultTimeout,l=c?.retries??this.config.defaultRetries,o=c?.method??"POST",p=0;for(;p<=l;)try{return p>0&&(this.logger.info(`Webhook retry attempt ${p}/${l}`,{executionId:g,webhookUrl:a}),await n(Math.min(1e3*Math.pow(2,p-1),3e4))),await this.executeWebhookRequest(a,b,o,k,c?.headers,g,e)}catch(a){if(d=a,p++,!this.shouldRetryError(a))break}return{success:!1,workflowId:"webhook",status:"failed",executionTimeMs:Date.now()-e,error:d?.message??"Unknown error",errorCode:"WEBHOOK_FAILED",retryable:!1,triggeredAt:new Date,statusCode:500}}async scheduleAutomation(a,b,c,d){let e=m();if(c<=new Date)throw new g("Scheduled time must be in the future","INVALID_SCHEDULE_TIME",!1);let f={id:e,workflowId:a,payload:b,context:d??{orgId:"default"},runAt:c,status:"pending",createdAt:new Date};this.scheduledAutomations.set(e,f);let h=c.getTime()-Date.now();return setTimeout(async()=>{await this.executeScheduledAutomation(e)},h),this.logger.info(`Scheduled automation ${e}`,{workflowId:a,runAt:c.toISOString(),delayMs:h}),e}async cancelScheduled(a){let b=this.scheduledAutomations.get(a);if(!b)throw new g(`Scheduled automation not found: ${a}`,"SCHEDULE_NOT_FOUND",!1);if("pending"!==b.status)throw new g(`Cannot cancel automation with status: ${b.status}`,"INVALID_SCHEDULE_STATUS",!1);b.status="cancelled",this.scheduledAutomations.set(a,b),this.logger.info(`Cancelled scheduled automation ${a}`)}async getWorkflowStatus(a){let b=this.executionLog.get(a);if(b)return{executionId:a,workflowId:b.workflowId,status:b.status,startedAt:b.triggeredAt,finishedAt:b.completedAt,durationMs:b.executionTimeMs,mode:"trigger",retryCount:0,error:b.error?{message:b.error}:void 0};if(this.config.n8nApiKey)try{let b=await this.makeApiRequest(`/executions/${a}`,"GET");return this.mapN8nExecutionToStatus(b)}catch(b){this.logger.error("Failed to get execution status from n8n",b,{executionId:a})}throw new g(`Execution not found: ${a}`,"EXECUTION_NOT_FOUND",!1)}async listAvailableWorkflows(a){if(!this.config.n8nApiKey)return this.logger.warn("n8n API key not configured, returning cached workflows only"),Array.from(this.workflowCache.values()).filter(b=>b.orgId===a);try{let b=(await this.makeApiRequest("/workflows","GET")).data.map(b=>this.mapN8nWorkflowToWorkflow(b,a));for(let a of b)this.workflowCache.set(a.id,a);return b}catch(b){return this.logger.error("Failed to list workflows from n8n",b,{orgId:a}),Array.from(this.workflowCache.values()).filter(b=>b.orgId===a)}}getStats(){return{...this.stats,rateLimitStats:{global:this.rateLimiter.getStats("__global__")}}}getRecentExecutions(a=100){return this.executionLog.getRecent(a)}getScheduledAutomations(){return Array.from(this.scheduledAutomations.values())}async executeWebhookTrigger(a,b,c,d,e,f){let g,h=f?.timeout??this.config.defaultTimeout,i=f?.retries??this.config.defaultRetries,j=0;for(;j<=i;)try{return j>0&&(this.logger.info(`Trigger retry attempt ${j}/${i}`,{executionId:c,workflowId:d}),await n(Math.min(1e3*Math.pow(2,j-1),3e4))),{...await this.executeWebhookRequest(a,b,"POST",h,f?.headers,c,e),workflowId:d,executionId:c}}catch(a){if(g=a,j++,!this.shouldRetryError(a))break}return this.createFailedResult(d,e,"TRIGGER_FAILED",g?.message??"Webhook trigger failed",!1,c)}async executeApiTrigger(a,b,c,d,e){if(!this.config.n8nApiKey)return this.createFailedResult(a,d,"API_NOT_CONFIGURED","n8n API key not configured",!1,c);try{let f=await this.makeApiRequest(`/workflows/${a}/execute`,"POST",b,e?.timeout);return{success:!0,executionId:f.id??c,workflowId:a,data:f.data,status:this.mapN8nStatus(f.status),executionTimeMs:Date.now()-d,triggeredAt:new Date(d),completedAt:new Date}}catch(b){return this.createFailedResult(a,d,"API_TRIGGER_FAILED",b.message,this.shouldRetryError(b),c)}}async executeWebhookRequest(a,b,c,d,e,f,g){let h=g??Date.now(),i=new AbortController,j=setTimeout(()=>i.abort(),d);try{let d,g=await fetch(a,{method:c,headers:{"Content-Type":"application/json","User-Agent":"AstralisOps-AutomationTrigger/1.0","X-Execution-ID":f??m(),...e},body:"GET"!==c?JSON.stringify(b):void 0,signal:i.signal});clearTimeout(j);let k=await g.text();try{d=JSON.parse(k)}catch{}let l=Date.now()-h;if(!g.ok)return{success:!1,workflowId:"webhook",status:"failed",executionTimeMs:l,error:`HTTP ${g.status}: ${g.statusText}`,errorCode:`HTTP_${g.status}`,retryable:g.status>=500||429===g.status,triggeredAt:new Date(h),completedAt:new Date,statusCode:g.status,rawResponse:k};return{success:!0,executionId:f??m(),workflowId:"webhook",data:d,status:"success",executionTimeMs:l,triggeredAt:new Date(h),completedAt:new Date,statusCode:g.status,headers:Object.fromEntries(g.headers.entries()),rawResponse:k}}catch(b){clearTimeout(j);let a="AbortError"===b.name;return{success:!1,workflowId:"webhook",status:a?"timed_out":"failed",executionTimeMs:Date.now()-h,error:a?`Request timed out after ${d}ms`:b.message,errorCode:a?"TIMEOUT":"REQUEST_FAILED",retryable:a,triggeredAt:new Date(h),completedAt:new Date,statusCode:0}}}async executeScheduledAutomation(a){let b=this.scheduledAutomations.get(a);if(b&&"pending"===b.status){this.logger.info(`Executing scheduled automation ${a}`);try{let a=await this.trigger(b.workflowId,b.payload,b.context);b.status=a.success?"executed":"failed",b.result=a}catch(a){b.status="failed",b.result=this.createFailedResult(b.workflowId,b.runAt.getTime(),"SCHEDULED_EXECUTION_FAILED",a.message,!1)}this.scheduledAutomations.set(a,b)}}async getWorkflowDetails(a){if(this.workflowCache.has(a))return this.workflowCache.get(a)??null;if(this.config.n8nApiKey)try{let b=await this.makeApiRequest(`/workflows/${a}`,"GET"),c=this.mapN8nWorkflowToWorkflow(b,"default");return this.workflowCache.set(a,c),c}catch(b){this.logger.error("Failed to get workflow from n8n",b,{workflowId:a})}return null}async makeApiRequest(a,b,c,d){let e=`${this.config.n8nBaseUrl}/api/v1${a}`,f=d??this.config.defaultTimeout,g=new AbortController,h=setTimeout(()=>g.abort(),f);try{let a=await fetch(e,{method:b,headers:{"Content-Type":"application/json","X-N8N-API-KEY":this.config.n8nApiKey},body:c?JSON.stringify(c):void 0,signal:g.signal});if(clearTimeout(h),!a.ok)throw new j(`n8n API error: ${a.status} ${a.statusText}`,a.status,a.status>=500);return await a.json()}catch(a){if(clearTimeout(h),"AbortError"===a.name)throw new k("n8n-api",f);throw a}}createFailedResult(a,b,c,d,e,f){return{success:!1,executionId:f,workflowId:a,status:"failed",executionTimeMs:Date.now()-b,error:d,errorCode:c,retryable:e,triggeredAt:new Date(b),completedAt:new Date}}shouldRetryError(a){if(a instanceof g)return a.retryable;let b=a.message.toLowerCase();return b.includes("timeout")||b.includes("network")||b.includes("econnreset")||b.includes("socket")||b.includes("502")||b.includes("503")||b.includes("504")}updateStats(a){this.stats.totalTriggers++,a.success?this.stats.successfulTriggers++:this.stats.failedTriggers++;let b=this.stats.successfulTriggers+this.stats.failedTriggers;this.stats.averageExecutionTimeMs=(this.stats.averageExecutionTimeMs*(b-1)+a.executionTimeMs)/b}mapN8nWorkflowToWorkflow(a,b){let c;if(a.nodes){let b=a.nodes.find(a=>"n8n-nodes-base.webhook"===a.type);b?.parameters?.path&&(c=`${this.config.n8nBaseUrl}/webhook/${b.parameters.path}`)}return{id:a.id,name:a.name,description:a.settings?.description,type:this.inferWorkflowType(a),isActive:a.active,webhookUrl:c,orgId:b,tags:a.tags?.map(a=>a.name)??[],createdAt:new Date(a.createdAt),updatedAt:new Date(a.updatedAt),executionCount:0,successRate:1}}inferWorkflowType(a){let b=a.nodes?.map(a=>a.type.toLowerCase())??[];return b.some(a=>a.includes("email")||a.includes("sendgrid")||a.includes("mailgun"))?"email_sequence":b.some(a=>a.includes("slack"))?"slack_notification":b.some(a=>a.includes("salesforce")||a.includes("hubspot")||a.includes("crm"))?"crm_update":b.some(a=>a.includes("spreadsheet")||a.includes("google sheets")||a.includes("excel"))?"report_generation":"custom_integration"}mapN8nStatus(a){switch(a?.toLowerCase()){case"success":return"success";case"running":return"running";case"waiting":return"waiting";case"error":case"failed":return"failed";case"cancelled":return"cancelled";default:return"pending"}}mapN8nExecutionToStatus(a){return{executionId:a.id,workflowId:a.workflowId??"unknown",status:this.mapN8nStatus(a.status),startedAt:new Date(a.startedAt??Date.now()),finishedAt:a.finishedAt?new Date(a.finishedAt):void 0,durationMs:a.stoppedAt&&a.startedAt?new Date(a.stoppedAt).getTime()-new Date(a.startedAt).getTime():void 0,mode:a.mode,retryCount:0,data:a.data,error:a.error?{message:a.error.message,code:a.error.code}:void 0}}}function r(){let a=process.env.N8N_BASE_URL??process.env.NEXT_PUBLIC_N8N_BASE_URL,b=process.env.N8N_API_KEY;if(!a)throw Error("N8N_BASE_URL environment variable is required");return new q({n8nBaseUrl:a,n8nApiKey:b,defaultTimeout:parseInt(process.env.N8N_TIMEOUT??"30000",10),defaultRetries:parseInt(process.env.N8N_RETRIES??"3",10),rateLimitPerWorkflow:parseInt(process.env.N8N_RATE_LIMIT_PER_WORKFLOW??"30",10),globalRateLimit:parseInt(process.env.N8N_GLOBAL_RATE_LIMIT??"100",10),debug:!1})}var s=c(36073);c(79832),d.Ik({userId:d.Yj().min(1),orgId:d.Yj().optional(),title:d.Yj().min(1).max(200),description:d.Yj().max(5e3).optional(),startTime:d.p6(),endTime:d.p6(),timezone:d.Yj().optional(),location:d.Yj().max(500).optional(),createMeetingLink:d.zM().optional(),conferenceProvider:d.k5(["google_meet","zoom","teams","webex","custom"]).optional(),attendees:d.YO(d.Ik({id:d.Yj().nullable().optional(),email:d.Yj().email(),name:d.Yj().min(1),isRequired:d.zM().optional()})).optional(),visibility:d.k5(["default","public","private","confidential"]).optional(),reminders:d.YO(d.Ik({minutesBefore:d.ai().int().positive(),method:d.k5(["email","push","sms","popup"])})).optional(),recurrence:d.Ik({frequency:d.k5(["daily","weekly","monthly","yearly"]),interval:d.ai().int().positive(),daysOfWeek:d.YO(d.ai().int().min(0).max(6)).optional(),dayOfMonth:d.ai().int().min(1).max(31).optional(),endDate:d.p6().optional(),count:d.ai().int().positive().optional(),exceptions:d.YO(d.p6()).optional()}).optional(),metadata:d.g1(d.L5()).optional(),sendInvites:d.zM().optional()}),d.Ik({title:d.Yj().min(1).max(200).optional(),description:d.Yj().max(5e3).optional().nullable(),startTime:d.p6().optional(),endTime:d.p6().optional(),timezone:d.Yj().optional(),location:d.Yj().max(500).optional().nullable(),meetingLink:d.Yj().url().optional().nullable(),status:d.k5(["scheduled","confirmed","cancelled","completed","conflict"]).optional(),visibility:d.k5(["default","public","private","confidential"]).optional(),notifyAttendees:d.zM().optional()}),s.Ln.bufferMinutes,s.Ln.businessHours,s.Ln.lunchHours,s.Ln.maxMeetingsPerDay,s.Ln.maxConsecutiveHours;var t=c(48625);let u={rateLimits:{perMinute:10,perHour:50,perDay:200,urgentBurstLimit:5},deduplicationWindowSeconds:300,retry:{maxAttempts:3,baseDelayMs:1e3,maxDelayMs:3e4},services:{email:{provider:"sendgrid",fromAddress:"noreply@astralis.agency",fromName:"Astralis Agency"}}},v={debug:(a,b)=>{},info:(a,b)=>{console.info(`[NotificationDispatcher] ${a}`,b||"")},warn:(a,b)=>{console.warn(`[NotificationDispatcher] ${a}`,b||"")},error:(a,b,c)=>{console.error(`[NotificationDispatcher] ${a}`,b,c||"")}};class w{constructor(a,b){this.templates=new Map,this.rateLimitCache=new Map,this.deduplicationCache=new Map,this.scheduledNotifications=new Map,this.config={...u,...a},this.logger=b||v,this.initializeTemplates(),this.startDeduplicationCleanup()}async send(a){let b=Date.now();try{let c;if(this.validatePayload(a),a.deduplicationKey&&this.checkDeduplication(a.deduplicationKey))return this.logger.info("Notification deduplicated",{deduplicationKey:a.deduplicationKey}),{success:!0,channel:a.channel,recipient:a.recipient,status:"sent",timestamp:new Date,deduplicated:!0};let d=await this.checkRateLimit(a.recipient,a.priority);if(!d.allowed)return this.logger.warn("Rate limit exceeded",{recipient:a.recipient,limit:d.limit}),{success:!1,channel:a.channel,recipient:a.recipient,status:"failed",error:`Rate limit exceeded. Try again in ${d.retryAfterMs}ms`,timestamp:new Date};if(!1!==a.respectQuietHours){let b=await this.checkQuietHours(a.recipient,a.priority);if(b.inQuietHours&&"urgent"!==a.priority&&(this.logger.info("Notification deferred for quiet hours",{recipient:a.recipient,resumeAt:b.resumeAt}),b.resumeAt)){let c=await this.scheduleNotification(a,b.resumeAt);return{success:!0,notificationId:c,channel:a.channel,recipient:a.recipient,status:"queued",timestamp:new Date,deferredForQuietHours:!0}}}let e=a.subject,f=a.body;if(a.templateId){let b=await this.renderTemplate(a.templateId,a.templateData||{});e=b.subject,f=b.body}let g=await this.personalizeContent(f,a.recipient,a.metadata);switch(a.channel){case"email":c=await this.sendViaEmail(a.recipient,e,g,a);break;case"in_app":c=await this.sendViaInApp(a.recipient,e,g,a);break;case"sms":c=await this.sendViaSMS(a.recipient,g,a);break;case"push":c=await this.sendViaPush(a.recipient,e,g,a);break;default:throw Error(`Unsupported notification channel: ${a.channel}`)}a.deduplicationKey&&c.success&&this.recordDeduplication(a.deduplicationKey),c.success&&this.recordRateLimitUsage(a.recipient),await this.storeNotificationRecord({...a,subject:e,body:g},c);let h=Date.now()-b;return this.logger.info("Notification sent",{channel:a.channel,recipient:a.recipient,success:c.success,processingTimeMs:h}),c}catch(c){let b=c instanceof Error?c.message:"Unknown error";return this.logger.error("Failed to send notification",c,{channel:a.channel,recipient:a.recipient}),{success:!1,channel:a.channel,recipient:a.recipient,status:"failed",error:b,timestamp:new Date}}}async sendEmail(a,b,c,d){let e=await this.send({channel:"email",recipient:a,subject:b,body:c,priority:"medium",metadata:d});if(!e.success)throw Error(`Failed to send email: ${e.error}`)}async sendInApp(a,b,c,d){let e=await this.send({channel:"in_app",recipient:a,subject:c,body:b,priority:"medium",notificationType:c,metadata:d});if(!e.success)throw Error(`Failed to send in-app notification: ${e.error}`)}async sendBulk(a){let b=Date.now(),c=[],d=0,e=0,f=0;for(let b of this.chunkArray(a,10))for(let a of(await Promise.all(b.map(a=>this.send(a)))))c.push(a),a.deduplicated?f++:a.success?d++:e++;let g=Date.now()-b;return this.logger.info("Bulk notifications sent",{total:a.length,successful:d,failed:e,deduplicated:f,processingTimeMs:g}),{total:a.length,successful:d,failed:e,deduplicated:f,results:c,processingTimeMs:g}}async scheduleNotification(a,b){let c=this.generateId(),d=b.getTime()-Date.now();if(d<=0)return await this.send(a),c;try{await t.z.$executeRaw`
        INSERT INTO scheduled_notifications (id, payload, scheduled_for, created_at, status)
        VALUES (${c}, ${JSON.stringify(a)}::jsonb, ${b}, NOW(), 'pending')
        ON CONFLICT DO NOTHING
      `}catch{this.logger.warn("scheduled_notifications table not found, using in-memory scheduling")}let e=setTimeout(async()=>{this.scheduledNotifications.delete(c),await this.send(a)},Math.min(d,0x7fffffff));return this.scheduledNotifications.set(c,e),this.logger.info("Notification scheduled",{notificationId:c,sendAt:b.toISOString(),delayMs:d}),c}async cancelScheduled(a){let b=this.scheduledNotifications.get(a);b&&(clearTimeout(b),this.scheduledNotifications.delete(a));try{await t.z.$executeRaw`
        UPDATE scheduled_notifications
        SET status = 'cancelled', updated_at = NOW()
        WHERE id = ${a}
      `}catch{this.logger.warn("Could not update scheduled_notifications table")}this.logger.info("Scheduled notification cancelled",{notificationId:a})}async getNotificationHistory(a,b=50){try{return(await t.z.$queryRaw`
        SELECT * FROM in_app_notifications
        WHERE user_id = ${a}
        ORDER BY created_at DESC
        LIMIT ${b}
      `).map(a=>({id:a.id,channel:a.channel,recipient:a.user_id,subject:a.subject,body:a.body,priority:a.priority,status:a.status,metadata:a.metadata,actionUrl:a.action_url||void 0,sentAt:a.sent_at||void 0,deliveredAt:a.delivered_at||void 0,readAt:a.read_at||void 0,createdAt:a.created_at,updatedAt:a.updated_at,externalId:a.external_id||void 0,errorMessage:a.error_message||void 0,retryCount:a.retry_count}))}catch{return this.logger.warn("in_app_notifications table not found"),[]}}async markAsRead(a,b){try{await t.z.$executeRaw`
        UPDATE in_app_notifications
        SET read_at = NOW(), status = 'delivered', updated_at = NOW()
        WHERE id = ${a} AND user_id = ${b}
      `}catch{this.logger.warn("Could not mark notification as read",{notificationId:a,userId:b})}}async getUnreadCount(a){try{let b=await t.z.$queryRaw`
        SELECT COUNT(*) as count FROM in_app_notifications
        WHERE user_id = ${a} AND read_at IS NULL
      `;return Number(b[0].count)}catch{return 0}}registerTemplate(a){this.templates.set(a.id,a),this.logger.debug("Template registered",{templateId:a.id})}destroy(){for(let[a,b]of this.scheduledNotifications)clearTimeout(b),this.scheduledNotifications.delete(a);this.logger.info("NotificationDispatcher destroyed")}async sendViaEmail(a,b,c,d){let e=this.config.services.email;if(!e)return{success:!1,channel:"email",recipient:a,status:"failed",error:"Email service not configured",timestamp:new Date};try{switch(e.provider){case"sendgrid":this.logger.debug("Would send via SendGrid",{to:a,subject:b});break;case"ses":this.logger.debug("Would send via AWS SES",{to:a,subject:b});break;case"resend":this.logger.debug("Would send via Resend",{to:a,subject:b});break;default:this.logger.debug("Would send via SMTP",{to:a,subject:b})}let d=this.generateId();try{await t.z.$executeRaw`
          INSERT INTO email_queue (id, to_address, subject, body, status, created_at)
          VALUES (${d}, ${a}, ${b}, ${c}, 'queued', NOW())
          ON CONFLICT DO NOTHING
        `}catch{}return{success:!0,notificationId:d,channel:"email",recipient:a,status:"queued",timestamp:new Date}}catch(b){return{success:!1,channel:"email",recipient:a,status:"failed",error:b instanceof Error?b.message:"Unknown error",timestamp:new Date}}}async sendViaInApp(a,b,c,d){try{let e=this.generateId();try{await t.z.$executeRaw`
          INSERT INTO in_app_notifications (
            id, user_id, channel, subject, body, priority, status,
            metadata, action_url, created_at, updated_at, retry_count
          )
          VALUES (
            ${e}, ${a}, 'in_app', ${b}, ${c},
            ${d.priority}, 'sent', ${JSON.stringify(d.metadata||{})}::jsonb,
            ${d.actionUrl||null}, NOW(), NOW(), 0
          )
        `}catch(a){this.logger.warn("in_app_notifications table not found, notification not persisted",{error:a instanceof Error?a.message:"Unknown error"})}return{success:!0,notificationId:e,channel:"in_app",recipient:a,status:"sent",timestamp:new Date}}catch(b){return{success:!1,channel:"in_app",recipient:a,status:"failed",error:b instanceof Error?b.message:"Unknown error",timestamp:new Date}}}async sendViaSMS(a,b,c){let d=this.config.services.sms;if(!d)return{success:!1,channel:"sms",recipient:a,status:"failed",error:"SMS service not configured",timestamp:new Date};try{switch(d.provider){case"twilio":this.logger.debug("Would send via Twilio",{to:a,messageLength:b.length});break;case"vonage":this.logger.debug("Would send via Vonage",{to:a});break;case"aws-sns":this.logger.debug("Would send via AWS SNS",{to:a})}let c=this.generateId();return{success:!0,notificationId:c,channel:"sms",recipient:a,status:"queued",timestamp:new Date}}catch(b){return{success:!1,channel:"sms",recipient:a,status:"failed",error:b instanceof Error?b.message:"Unknown error",timestamp:new Date}}}async sendViaPush(a,b,c,d){let e=this.config.services.push;if(!e)return{success:!1,channel:"push",recipient:a,status:"failed",error:"Push notification service not configured",timestamp:new Date};try{switch(e.provider){case"fcm":this.logger.debug("Would send via FCM",{userId:a,title:b});break;case"apns":this.logger.debug("Would send via APNs",{userId:a,title:b});break;case"expo":this.logger.debug("Would send via Expo",{userId:a,title:b})}let c=this.generateId();return{success:!0,notificationId:c,channel:"push",recipient:a,status:"queued",timestamp:new Date}}catch(b){return{success:!1,channel:"push",recipient:a,status:"failed",error:b instanceof Error?b.message:"Unknown error",timestamp:new Date}}}validatePayload(a){if(!a.channel)throw Error("Notification channel is required");if(!a.recipient)throw Error("Notification recipient is required");if(!a.subject&&"sms"!==a.channel)throw Error("Notification subject is required");if(!a.body&&!a.templateId)throw Error("Notification body or templateId is required");if("email"===a.channel&&!this.isValidEmail(a.recipient))throw Error("Invalid email address");if("sms"===a.channel&&!this.isValidPhone(a.recipient))throw Error("Invalid phone number")}isValidEmail(a){return/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(a)}isValidPhone(a){return/^\+?[\d\s\-\(\)]{10,}$/.test(a)}async checkRateLimit(a,b){let c=new Date,d=this.config.rateLimits,e=this.rateLimitCache.get(a)||[],f=new Date(c.getTime()-6e4),g=new Date(c.getTime()-36e5),h=new Date(c.getTime()-864e5),i=(e=e.filter(a=>a.resetAt>h)).filter(a=>a.resetAt>f).length,j=e.filter(a=>a.resetAt>g).length,k=e.length;return i>=("urgent"===b?d.perMinute+d.urgentBurstLimit:d.perMinute)?{allowed:!1,limit:"perMinute",retryAfterMs:6e4-(c.getTime()-f.getTime())}:j>=d.perHour?{allowed:!1,limit:"perHour",retryAfterMs:36e5-(c.getTime()-g.getTime())}:k>=d.perDay?{allowed:!1,limit:"perDay",retryAfterMs:864e5-(c.getTime()-h.getTime())}:{allowed:!0}}recordRateLimitUsage(a){let b=this.rateLimitCache.get(a)||[];b.push({count:1,resetAt:new Date(Date.now()+864e5)}),this.rateLimitCache.set(a,b)}async checkQuietHours(a,b){let c=this.config.defaultQuietHours;if(!c?.enabled||"urgent"===b&&c.allowUrgent)return{inQuietHours:!1};let d=new Date,[e,f]=c.startTime.split(":").map(Number),[g,h]=c.endTime.split(":").map(Number),i=60*d.getHours()+d.getMinutes(),j=60*e+f,k=60*g+h,l=!1;if((l=j<=k?i>=j&&i<k:i>=j||i<k)&&c.daysOfWeek){let a=d.getDay();c.daysOfWeek.includes(a)||(l=!1)}if(l){let a=new Date(d);return j<=k||i>=j&&a.setDate(a.getDate()+1),a.setHours(g,h,0,0),{inQuietHours:!0,resumeAt:a}}return{inQuietHours:!1}}checkDeduplication(a){let b=this.deduplicationCache.get(a);if(!b)return!1;let c=1e3*this.config.deduplicationWindowSeconds;return Date.now()-b.getTime()<c||(this.deduplicationCache.delete(a),!1)}recordDeduplication(a){this.deduplicationCache.set(a,new Date)}startDeduplicationCleanup(){setInterval(()=>{let a=1e3*this.config.deduplicationWindowSeconds,b=new Date(Date.now()-a);for(let[a,c]of this.deduplicationCache)c<b&&this.deduplicationCache.delete(a)},6e4)}async renderTemplate(a,b){let c=this.templates.get(a);if(!c)throw Error(`Template not found: ${a}`);let d={...c.defaultData,...b},e=c.subject,f=c.bodyTemplate;for(let[a,b]of Object.entries(d)){let c=RegExp(`{{\\s*${a}\\s*}}`,"g"),d=String(b??"");e=e.replace(c,d),f=f.replace(c,d)}return{subject:e,body:f}}async personalizeContent(a,b,c){let d=a;try{let a=await t.z.users.findFirst({where:{OR:[{id:b},{email:b}]},select:{name:!0,email:!0}});if(a){let b=a.name?.split(" ")[0]||"there";d=d.replace(/{{user\.name}}/g,a.name||"").replace(/{{user\.firstName}}/g,b).replace(/{{user\.email}}/g,a.email)}}catch{}if(c)for(let[a,b]of Object.entries(c)){let c=RegExp(`{{\\s*${a}\\s*}}`,"g");d=d.replace(c,String(b??""))}return d}async storeNotificationRecord(a,b){try{await t.z.$executeRaw`
        INSERT INTO notification_logs (
          id, channel, recipient, subject, body, priority, status,
          metadata, action_url, external_id, error_message, created_at
        )
        VALUES (
          ${b.notificationId||this.generateId()},
          ${a.channel},
          ${a.recipient},
          ${a.subject},
          ${a.body},
          ${a.priority},
          ${b.status},
          ${JSON.stringify(a.metadata||{})}::jsonb,
          ${a.actionUrl||null},
          ${b.externalId||null},
          ${b.error||null},
          NOW()
        )
        ON CONFLICT DO NOTHING
      `}catch{this.logger.debug("Could not store notification log")}}initializeTemplates(){this.templates.set("welcome",{id:"welcome",name:"Welcome Email",channel:"email",subject:"Welcome to {{appName}}!",bodyTemplate:`
Hi {{user.firstName}},

Welcome to {{appName}}! We're excited to have you on board.

Here are a few things you can do to get started:
- Complete your profile
- Explore our features
- Connect with your team

If you have any questions, feel free to reach out to our support team.

Best regards,
The {{appName}} Team
      `.trim(),variables:["user.firstName","appName"],defaultData:{appName:"Astralis"}}),this.templates.set("task_assigned",{id:"task_assigned",name:"Task Assigned Notification",channel:"in_app",subject:"New Task Assigned",bodyTemplate:"You have been assigned a new task: {{taskName}}",variables:["taskName"]}),this.templates.set("meeting_reminder",{id:"meeting_reminder",name:"Meeting Reminder",channel:"push",subject:"Meeting Starting Soon",bodyTemplate:'Your meeting "{{meetingTitle}}" starts in {{minutesBefore}} minutes',variables:["meetingTitle","minutesBefore"]}),this.templates.set("intake_received",{id:"intake_received",name:"Intake Received Confirmation",channel:"email",subject:"We received your inquiry",bodyTemplate:`
Hi {{user.firstName}},

Thank you for reaching out! We've received your inquiry and a member of our team will be in touch shortly.

Reference: {{intakeId}}
Subject: {{subject}}

Best regards,
The {{appName}} Team
      `.trim(),variables:["user.firstName","intakeId","subject","appName"],defaultData:{appName:"Astralis"}})}generateId(){return`ntf_${Date.now()}_${Math.random().toString(36).substring(2,11)}`}chunkArray(a,b){let c=[];for(let d=0;d<a.length;d+=b)c.push(a.slice(d,d+b));return c}}let x=new w},84895:(a,b,c)=>{c.d(b,{VC:()=>k});var d=c(48625);class e extends Error{constructor(a,b,c,d){super(a),this.code=b,this.intakeId=c,this.details=d,this.name="PipelineAssignmentError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,e)}}class f extends e{constructor(a,b,c){super(a,"VALIDATION_ERROR",b,c),this.name="ValidationError"}}class g extends e{constructor(a,b,c){super(`${a.charAt(0).toUpperCase()+a.slice(1)} not found: ${b}`,`${a.toUpperCase()}_NOT_FOUND`,"intake"===a?b:void 0,c),this.name="NotFoundError"}}class h extends e{constructor(a,b,c){super(a,"PERMISSION_DENIED",b,c),this.name="PermissionError"}}class i extends e{constructor(a,b,c){super(a,"INVALID_STATE",b,c),this.name="InvalidStateError"}}let j="undefined"!=typeof process&&!1;class k{constructor(a){this.lastAssignedIndex=new Map,this.orgId=a.orgId,this.logger=a.logger??(a=>({debug:(b,c)=>{j&&console.debug(`[${a}] ${b}`,c??"")},info:(b,c)=>{console.info(`[${a}] ${b}`,c??"")},warn:(b,c)=>{console.warn(`[${a}] ${b}`,c??"")},error:(b,c,d)=>{console.error(`[${a}] ${b}`,c,d??"")}}))("PipelineAssigner"),this.agentId=a.agentId,this.userId=a.userId,this.isAgentAction=a.isAgentAction??!0,this.debug=a.debug??!1,this.logger.info("PipelineAssigner initialized",{orgId:this.orgId,isAgentAction:this.isAgentAction})}async assign(a,b,c,e){let g=Date.now();try{this.logger.info("Assigning intake to pipeline",{intakeId:a,pipelineId:b,stageId:c,assigneeId:e});let h=await this.fetchIntakeRequest(a);this.validateIntakeNotClosed(h);let i=await this.fetchPipeline(b);this.validatePipelineActive(i);let j=c??this.getDefaultStage(i)?.id;if(!j)throw new f("Pipeline has no stages configured",a,{pipelineId:b});this.validateStageInPipeline(j,i),e&&await this.validateUserExists(e);let k=this.captureIntakeState(h),l=await d.z.intakeRequest.update({where:{id:a},data:{assignedPipeline:b,status:"ASSIGNED",aiRoutingMeta:{...h.aiRoutingMeta,assignedAt:new Date().toISOString(),assignedByAgent:this.isAgentAction,agentId:this.agentId}},include:{pipeline:{include:{stages:{orderBy:{order:"asc"}}}}}}),m=await d.z.pipelineItem.create({data:{title:h.title,description:h.description,stageId:j,assignedToId:e??null,priority:h.priority,status:"NOT_STARTED",tags:[],progress:0,data:{intakeRequestId:a,source:h.source,requestData:h.requestData}}}),n=this.captureIntakeState({...l,assignedPipeline:b,status:"ASSIGNED"});n.stageId=j,n.assigneeId=e??null;let o=await this.createAuditLog({entityType:"intakeRequest",entityId:a,action:"ASSIGN_TO_PIPELINE",previousState:k,newState:n,metadata:{pipelineItemId:m.id}}),p={success:!0,intakeId:a,previousState:k,newState:n,auditLogId:o,timestamp:new Date};return this.logger.info("Intake assigned to pipeline successfully",{intakeId:a,pipelineId:b,pipelineItemId:m.id,processingTimeMs:Date.now()-g}),p}catch(b){return this.handleError(a,b,"assign")}}async reassign(a,b,c){let e=Date.now();try{this.logger.info("Reassigning intake to new pipeline",{intakeId:a,newPipelineId:b,reason:c});let g=await this.fetchIntakeRequest(a);this.validateIntakeNotClosed(g);let h=await this.fetchPipeline(b);if(this.validatePipelineActive(h),!this.getDefaultStage(h))throw new f("New pipeline has no stages configured",a,{pipelineId:b});let i=this.captureIntakeState(g),j=await d.z.intakeRequest.update({where:{id:a},data:{assignedPipeline:b,status:"ROUTING",aiRoutingMeta:{...g.aiRoutingMeta,reassignedAt:new Date().toISOString(),reassignReason:c,previousPipeline:g.assignedPipeline}},include:{pipeline:{include:{stages:{orderBy:{order:"asc"}}}}}}),k=this.captureIntakeState(j),l=await this.createAuditLog({entityType:"intakeRequest",entityId:a,action:"REASSIGN_TO_PIPELINE",previousState:i,newState:k,reason:c}),m={success:!0,intakeId:a,previousState:i,newState:k,auditLogId:l,timestamp:new Date};return this.logger.info("Intake reassigned to new pipeline successfully",{intakeId:a,oldPipelineId:i.pipelineId,newPipelineId:b,processingTimeMs:Date.now()-e}),m}catch(b){return this.handleError(a,b,"reassign")}}async moveToStage(a,b){let c=Date.now();try{this.logger.info("Moving item to stage",{intakeId:a,stageId:b});let e=await this.fetchPipelineItemByIntakeId(a);if(!e)throw new g("pipelineItem",a);let f=await d.z.pipelineStage.findUnique({where:{id:e.stageId},include:{pipeline:{include:{stages:{orderBy:{order:"asc"}}}}}});if(!f)throw new g("stage",e.stageId);let h=f.pipeline;this.validateStageInPipeline(b,h);let i=h.stages.find(a=>a.id===b),j=i?.order===Math.max(...h.stages.map(a=>a.order)),k=this.capturePipelineItemState(e,f.name),l=await d.z.pipelineItem.update({where:{id:e.id},data:{stageId:b,status:j?"COMPLETED":"IN_PROGRESS"},include:{stage:!0}}),m=this.capturePipelineItemState(l,i?.name),n=await this.createAuditLog({entityType:"pipelineItem",entityId:e.id,action:"MOVE_TO_STAGE",previousState:k,newState:m}),o={success:!0,intakeId:e.id,previousState:k,newState:m,auditLogId:n,timestamp:new Date};return this.logger.info("Item moved to stage successfully",{pipelineItemId:e.id,previousStageId:k.stageId,newStageId:b,processingTimeMs:Date.now()-c}),o}catch(b){return this.handleError(a,b,"moveToStage")}}async setAssignee(a,b){let c=Date.now();try{let e;this.logger.info("Setting item assignee",{intakeId:a,userId:b});let f=await this.fetchPipelineItemByIntakeId(a);if(!f)throw new g("pipelineItem",a);b&&await this.validateUserExists(b);let h=this.capturePipelineItemState(f),i=await d.z.pipelineItem.update({where:{id:f.id},data:{assignedToId:b},include:{stage:!0}});if(b){let a=await d.z.users.findUnique({where:{id:b},select:{name:!0}});e=a?.name??void 0}let j=this.capturePipelineItemState(i);j.assigneeName=e;let k=await this.createAuditLog({entityType:"pipelineItem",entityId:f.id,action:"SET_ASSIGNEE",previousState:h,newState:j}),l={success:!0,intakeId:f.id,previousState:h,newState:j,auditLogId:k,timestamp:new Date};return this.logger.info("Item assignee set successfully",{pipelineItemId:f.id,previousAssigneeId:h.assigneeId,newAssigneeId:b,processingTimeMs:Date.now()-c}),l}catch(b){return this.handleError(a,b,"setAssignee")}}async setPriority(a,b){let c=Date.now();try{if(b<1||b>5||!Number.isInteger(b))throw new f("Priority must be an integer between 1 and 5",a,{providedPriority:b});this.logger.info("Setting item priority",{intakeId:a,priority:b});let e=await this.fetchPipelineItemByIntakeId(a);if(!e)throw new g("pipelineItem",a);let h=this.capturePipelineItemState(e);await d.z.pipelineItem.update({where:{id:e.id},data:{priority:b}});let i={...h,priority:b};await this.createAuditLog({entityType:"pipelineItem",entityId:e.id,action:"SET_PRIORITY",previousState:h,newState:i}),this.logger.info("Item priority set successfully",{pipelineItemId:e.id,previousPriority:h.priority,newPriority:b,processingTimeMs:Date.now()-c})}catch(c){throw this.logger.error("Failed to set priority",c,{intakeId:a,priority:b}),c}}async addTags(a,b){let c=Date.now();try{if(!Array.isArray(b)||0===b.length)throw new f("Tags must be a non-empty array of strings",a,{providedTags:b});let e=b.map(a=>a.trim().toLowerCase()).filter(a=>a.length>0);if(0===e.length)throw new f("No valid tags provided after sanitization",a,{providedTags:b});this.logger.info("Adding tags to item",{intakeId:a,tags:e});let h=await this.fetchPipelineItemByIntakeId(a);if(!h)throw new g("pipelineItem",a);let i=this.capturePipelineItemState(h),j=h.tags||[],k=[...new Set([...j,...e])];await d.z.pipelineItem.update({where:{id:h.id},data:{tags:k}});let l={...i,tags:k};await this.createAuditLog({entityType:"pipelineItem",entityId:h.id,action:"ADD_TAGS",previousState:i,newState:l,metadata:{addedTags:e}}),this.logger.info("Tags added to item successfully",{pipelineItemId:h.id,addedTags:e,totalTags:k.length,processingTimeMs:Date.now()-c})}catch(c){throw this.logger.error("Failed to add tags",c,{intakeId:a,tags:b}),c}}async selectOptimalAssignee(a,b={}){let{maxWorkload:c=20,preferredAssigneeId:d,useRoundRobin:e=!0}=b;try{this.logger.debug("Selecting optimal assignee",{pipelineId:a,maxWorkload:c,preferredAssigneeId:d});let b=await this.getOrgMembersWithWorkload();if(0===b.length)return this.logger.warn("No team members found for organization",{orgId:this.orgId}),null;let f=b.filter(a=>a.isAvailable&&a.currentLoad<c);if(0===f.length)return this.logger.warn("No available team members within capacity",{orgId:this.orgId,totalMembers:b.length}),null;if(d){let a=f.find(a=>a.userId===d);if(a)return this.logger.debug("Using preferred assignee",{userId:d,currentLoad:a.currentLoad}),this.workloadInfoToUserSummary(a)}f.sort((a,b)=>a.currentLoad-b.currentLoad);let g=f[0].currentLoad,h=f.filter(a=>a.currentLoad===g);if(h.length>1&&e){let b=((this.lastAssignedIndex.get(a)??-1)+1)%h.length;this.lastAssignedIndex.set(a,b);let c=h[b];return this.logger.debug("Selected assignee via round-robin",{userId:c.userId,roundRobinIndex:b}),this.workloadInfoToUserSummary(c)}let i=f[0];return this.logger.debug("Selected assignee with lowest workload",{userId:i.userId,currentLoad:i.currentLoad}),this.workloadInfoToUserSummary(i)}catch(b){throw this.logger.error("Failed to select optimal assignee",b,{pipelineId:a}),b}}async getOrgMembersWithWorkload(){let a=await d.z.users.findMany({where:{orgId:this.orgId,isActive:!0,role:{in:["ADMIN","PM","OPERATOR","EDITOR"]}},select:{id:!0,name:!0,email:!0,role:!0}}),b=a.map(a=>a.id),c=await d.z.pipelineItem.groupBy({by:["assignedToId"],where:{assignedToId:{in:b},status:{notIn:["COMPLETED","CANCELLED"]}},_count:{id:!0}}),e=new Map;for(let a of c)a.assignedToId&&e.set(a.assignedToId,a._count.id);return a.map(a=>({userId:a.id,userName:a.name??"Unknown",userEmail:a.email,userRole:a.role,currentLoad:e.get(a.id)??0,maxLoad:20,availableCapacity:20-(e.get(a.id)??0),isAvailable:!0,lastAssignedAt:void 0}))}workloadInfoToUserSummary(a){return{id:a.userId,name:a.userName,email:a.userEmail,role:a.userRole,currentLoad:a.currentLoad,maxLoad:a.maxLoad,isAvailable:a.isAvailable}}async fetchIntakeRequest(a){let b=await d.z.intakeRequest.findUnique({where:{id:a},include:{pipeline:{include:{stages:{orderBy:{order:"asc"}}}}}});if(!b)throw new g("intake",a);if(b.orgId!==this.orgId)throw new h("Intake does not belong to this organization",a,{intakeOrgId:b.orgId,requestedOrgId:this.orgId});return b}async fetchPipelineItemByIntakeId(a){let b=await d.z.pipelineItem.findUnique({where:{id:a},include:{stage:!0}});if(b)return b;let c=await d.z.pipelineItem.findMany({where:{data:{path:["intakeRequestId"],equals:a}},include:{stage:!0},take:1});return c.length>0?c[0]:null}async fetchPipeline(a){let b=await d.z.pipeline.findUnique({where:{id:a},include:{stages:{orderBy:{order:"asc"}}}});if(!b)throw new g("pipeline",a);return b}validateIntakeNotClosed(a){if(["COMPLETED","REJECTED"].includes(a.status.toUpperCase()))throw new i(`Cannot modify intake with status "${a.status}"`,a.id,{status:a.status})}validatePipelineActive(a){if(!a.isActive)throw new f("Cannot assign to inactive pipeline",void 0,{pipelineId:a.id,pipelineName:a.name})}validateStageInPipeline(a,b){if(!b.stages.some(b=>b.id===a))throw new f("Stage does not belong to the specified pipeline",void 0,{stageId:a,pipelineId:b.id,availableStages:b.stages.map(a=>a.id)})}async validateUserExists(a){if(!await d.z.users.findUnique({where:{id:a},select:{id:!0}}))throw new g("user",a)}getDefaultStage(a){return a.stages[0]}captureIntakeState(a){return{pipelineId:a.assignedPipeline,pipelineName:a.pipeline?.name,stageId:null,stageName:void 0,assigneeId:null,assigneeName:void 0,priority:a.priority,tags:[],status:a.status}}capturePipelineItemState(a,b){return{pipelineId:null,pipelineName:void 0,stageId:a.stageId,stageName:b??a.stage?.name,assigneeId:a.assignedToId,assigneeName:void 0,priority:a.priority,tags:a.tags||[],status:a.status}}async createAuditLog(a){try{let b=await d.z.activityLog.create({data:{id:function(){let a=Date.now().toString(36),b=Math.random().toString(36).substring(2,15);return`${a}${b}`}(),orgId:this.orgId,userId:this.isAgentAction?this.agentId:this.userId,action:a.action,entity:a.entityType,entityId:a.entityId,changes:{previousState:a.previousState,newState:a.newState,reason:a.reason},metadata:{...a.metadata??{},performedByType:this.isAgentAction?"agent":"human",agentId:this.agentId}}});return this.logger.debug("Audit log created",{auditLogId:b.id,action:a.action,entityId:a.entityId}),b.id}catch(b){this.logger.error("Failed to create audit log",b,{entityId:a.entityId,action:a.action});return}}handleError(a,b,c){let d=b instanceof Error?b.message:"Unknown error occurred";return this.logger.error(`Failed to ${c} intake`,b,{intakeId:a}),{success:!1,intakeId:a,previousState:{pipelineId:null,stageId:null,assigneeId:null,priority:0,tags:[],status:"unknown"},newState:{pipelineId:null,stageId:null,assigneeId:null,priority:0,tags:[],status:"error"},error:d,timestamp:new Date}}updateConfig(a){void 0!==a.agentId&&(this.agentId=a.agentId),void 0!==a.userId&&(this.userId=a.userId),void 0!==a.isAgentAction&&(this.isAgentAction=a.isAgentAction),void 0!==a.debug&&(this.debug=a.debug),this.logger.debug("Configuration updated",a)}async getPipelineSummaries(){return(await d.z.pipeline.findMany({where:{isActive:!0},include:{stages:{orderBy:{order:"asc"}}}})).map(a=>({id:a.id,name:a.name,stages:a.stages.map(a=>a.name),category:"general",description:a.description??void 0,isActive:a.isActive}))}}}};