"use strict";exports.id=2932,exports.ids=[2932],exports.modules={2932:(a,b,c)=>{c.d(b,{VC:()=>k});var d=c(96798);class e extends Error{constructor(a,b,c,d){super(a),this.code=b,this.intakeId=c,this.details=d,this.name="PipelineAssignmentError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,e)}}class f extends e{constructor(a,b,c){super(a,"VALIDATION_ERROR",b,c),this.name="ValidationError"}}class g extends e{constructor(a,b,c){super(`${a.charAt(0).toUpperCase()+a.slice(1)} not found: ${b}`,`${a.toUpperCase()}_NOT_FOUND`,"intake"===a?b:void 0,c),this.name="NotFoundError"}}class h extends e{constructor(a,b,c){super(a,"PERMISSION_DENIED",b,c),this.name="PermissionError"}}class i extends e{constructor(a,b,c){super(a,"INVALID_STATE",b,c),this.name="InvalidStateError"}}let j="undefined"!=typeof process&&!1;class k{constructor(a){this.lastAssignedIndex=new Map,this.orgId=a.orgId,this.logger=a.logger??(a=>({debug:(b,c)=>{j&&console.debug(`[${a}] ${b}`,c??"")},info:(b,c)=>{console.info(`[${a}] ${b}`,c??"")},warn:(b,c)=>{console.warn(`[${a}] ${b}`,c??"")},error:(b,c,d)=>{console.error(`[${a}] ${b}`,c,d??"")}}))("PipelineAssigner"),this.agentId=a.agentId,this.userId=a.userId,this.isAgentAction=a.isAgentAction??!0,this.debug=a.debug??!1,this.logger.info("PipelineAssigner initialized",{orgId:this.orgId,isAgentAction:this.isAgentAction})}async assign(a,b,c,e){let g=Date.now();try{this.logger.info("Assigning intake to pipeline",{intakeId:a,pipelineId:b,stageId:c,assigneeId:e});let h=await this.fetchIntakeRequest(a);this.validateIntakeNotClosed(h);let i=await this.fetchPipeline(b);this.validatePipelineActive(i);let j=c??this.getDefaultStage(i)?.id;if(!j)throw new f("Pipeline has no stages configured",a,{pipelineId:b});this.validateStageInPipeline(j,i),e&&await this.validateUserExists(e);let k=this.captureIntakeState(h),l=await d.z.intakeRequest.update({where:{id:a},data:{assignedPipeline:b,status:"ASSIGNED",aiRoutingMeta:{...h.aiRoutingMeta,assignedAt:new Date().toISOString(),assignedByAgent:this.isAgentAction,agentId:this.agentId}},include:{pipeline:{include:{stages:{orderBy:{order:"asc"}}}}}}),m=await d.z.pipelineItem.create({data:{title:h.title,description:h.description,stageId:j,assignedToId:e??null,priority:h.priority,status:"NOT_STARTED",tags:[],progress:0,data:{intakeRequestId:a,source:h.source,requestData:h.requestData}}}),n=this.captureIntakeState({...l,assignedPipeline:b,status:"ASSIGNED"});n.stageId=j,n.assigneeId=e??null;let o=await this.createAuditLog({entityType:"intakeRequest",entityId:a,action:"ASSIGN_TO_PIPELINE",previousState:k,newState:n,metadata:{pipelineItemId:m.id}}),p={success:!0,intakeId:a,previousState:k,newState:n,auditLogId:o,timestamp:new Date};return this.logger.info("Intake assigned to pipeline successfully",{intakeId:a,pipelineId:b,pipelineItemId:m.id,processingTimeMs:Date.now()-g}),p}catch(b){return this.handleError(a,b,"assign")}}async reassign(a,b,c){let e=Date.now();try{this.logger.info("Reassigning intake to new pipeline",{intakeId:a,newPipelineId:b,reason:c});let g=await this.fetchIntakeRequest(a);this.validateIntakeNotClosed(g);let h=await this.fetchPipeline(b);if(this.validatePipelineActive(h),!this.getDefaultStage(h))throw new f("New pipeline has no stages configured",a,{pipelineId:b});let i=this.captureIntakeState(g),j=await d.z.intakeRequest.update({where:{id:a},data:{assignedPipeline:b,status:"ROUTING",aiRoutingMeta:{...g.aiRoutingMeta,reassignedAt:new Date().toISOString(),reassignReason:c,previousPipeline:g.assignedPipeline}},include:{pipeline:{include:{stages:{orderBy:{order:"asc"}}}}}}),k=this.captureIntakeState(j),l=await this.createAuditLog({entityType:"intakeRequest",entityId:a,action:"REASSIGN_TO_PIPELINE",previousState:i,newState:k,reason:c}),m={success:!0,intakeId:a,previousState:i,newState:k,auditLogId:l,timestamp:new Date};return this.logger.info("Intake reassigned to new pipeline successfully",{intakeId:a,oldPipelineId:i.pipelineId,newPipelineId:b,processingTimeMs:Date.now()-e}),m}catch(b){return this.handleError(a,b,"reassign")}}async moveToStage(a,b){let c=Date.now();try{this.logger.info("Moving item to stage",{intakeId:a,stageId:b});let e=await this.fetchPipelineItemByIntakeId(a);if(!e)throw new g("pipelineItem",a);let f=await d.z.pipelineStage.findUnique({where:{id:e.stageId},include:{pipeline:{include:{stages:{orderBy:{order:"asc"}}}}}});if(!f)throw new g("stage",e.stageId);let h=f.pipeline;this.validateStageInPipeline(b,h);let i=h.stages.find(a=>a.id===b),j=i?.order===Math.max(...h.stages.map(a=>a.order)),k=this.capturePipelineItemState(e,f.name),l=await d.z.pipelineItem.update({where:{id:e.id},data:{stageId:b,status:j?"COMPLETED":"IN_PROGRESS"},include:{stage:!0}}),m=this.capturePipelineItemState(l,i?.name),n=await this.createAuditLog({entityType:"pipelineItem",entityId:e.id,action:"MOVE_TO_STAGE",previousState:k,newState:m}),o={success:!0,intakeId:e.id,previousState:k,newState:m,auditLogId:n,timestamp:new Date};return this.logger.info("Item moved to stage successfully",{pipelineItemId:e.id,previousStageId:k.stageId,newStageId:b,processingTimeMs:Date.now()-c}),o}catch(b){return this.handleError(a,b,"moveToStage")}}async setAssignee(a,b){let c=Date.now();try{let e;this.logger.info("Setting item assignee",{intakeId:a,userId:b});let f=await this.fetchPipelineItemByIntakeId(a);if(!f)throw new g("pipelineItem",a);b&&await this.validateUserExists(b);let h=this.capturePipelineItemState(f),i=await d.z.pipelineItem.update({where:{id:f.id},data:{assignedToId:b},include:{stage:!0}});if(b){let a=await d.z.users.findUnique({where:{id:b},select:{name:!0}});e=a?.name??void 0}let j=this.capturePipelineItemState(i);j.assigneeName=e;let k=await this.createAuditLog({entityType:"pipelineItem",entityId:f.id,action:"SET_ASSIGNEE",previousState:h,newState:j}),l={success:!0,intakeId:f.id,previousState:h,newState:j,auditLogId:k,timestamp:new Date};return this.logger.info("Item assignee set successfully",{pipelineItemId:f.id,previousAssigneeId:h.assigneeId,newAssigneeId:b,processingTimeMs:Date.now()-c}),l}catch(b){return this.handleError(a,b,"setAssignee")}}async setPriority(a,b){let c=Date.now();try{if(b<1||b>5||!Number.isInteger(b))throw new f("Priority must be an integer between 1 and 5",a,{providedPriority:b});this.logger.info("Setting item priority",{intakeId:a,priority:b});let e=await this.fetchPipelineItemByIntakeId(a);if(!e)throw new g("pipelineItem",a);let h=this.capturePipelineItemState(e);await d.z.pipelineItem.update({where:{id:e.id},data:{priority:b}});let i={...h,priority:b};await this.createAuditLog({entityType:"pipelineItem",entityId:e.id,action:"SET_PRIORITY",previousState:h,newState:i}),this.logger.info("Item priority set successfully",{pipelineItemId:e.id,previousPriority:h.priority,newPriority:b,processingTimeMs:Date.now()-c})}catch(c){throw this.logger.error("Failed to set priority",c,{intakeId:a,priority:b}),c}}async addTags(a,b){let c=Date.now();try{if(!Array.isArray(b)||0===b.length)throw new f("Tags must be a non-empty array of strings",a,{providedTags:b});let e=b.map(a=>a.trim().toLowerCase()).filter(a=>a.length>0);if(0===e.length)throw new f("No valid tags provided after sanitization",a,{providedTags:b});this.logger.info("Adding tags to item",{intakeId:a,tags:e});let h=await this.fetchPipelineItemByIntakeId(a);if(!h)throw new g("pipelineItem",a);let i=this.capturePipelineItemState(h),j=h.tags||[],k=[...new Set([...j,...e])];await d.z.pipelineItem.update({where:{id:h.id},data:{tags:k}});let l={...i,tags:k};await this.createAuditLog({entityType:"pipelineItem",entityId:h.id,action:"ADD_TAGS",previousState:i,newState:l,metadata:{addedTags:e}}),this.logger.info("Tags added to item successfully",{pipelineItemId:h.id,addedTags:e,totalTags:k.length,processingTimeMs:Date.now()-c})}catch(c){throw this.logger.error("Failed to add tags",c,{intakeId:a,tags:b}),c}}async selectOptimalAssignee(a,b={}){let{maxWorkload:c=20,preferredAssigneeId:d,useRoundRobin:e=!0}=b;try{this.logger.debug("Selecting optimal assignee",{pipelineId:a,maxWorkload:c,preferredAssigneeId:d});let b=await this.getOrgMembersWithWorkload();if(0===b.length)return this.logger.warn("No team members found for organization",{orgId:this.orgId}),null;let f=b.filter(a=>a.isAvailable&&a.currentLoad<c);if(0===f.length)return this.logger.warn("No available team members within capacity",{orgId:this.orgId,totalMembers:b.length}),null;if(d){let a=f.find(a=>a.userId===d);if(a)return this.logger.debug("Using preferred assignee",{userId:d,currentLoad:a.currentLoad}),this.workloadInfoToUserSummary(a)}f.sort((a,b)=>a.currentLoad-b.currentLoad);let g=f[0].currentLoad,h=f.filter(a=>a.currentLoad===g);if(h.length>1&&e){let b=((this.lastAssignedIndex.get(a)??-1)+1)%h.length;this.lastAssignedIndex.set(a,b);let c=h[b];return this.logger.debug("Selected assignee via round-robin",{userId:c.userId,roundRobinIndex:b}),this.workloadInfoToUserSummary(c)}let i=f[0];return this.logger.debug("Selected assignee with lowest workload",{userId:i.userId,currentLoad:i.currentLoad}),this.workloadInfoToUserSummary(i)}catch(b){throw this.logger.error("Failed to select optimal assignee",b,{pipelineId:a}),b}}async getOrgMembersWithWorkload(){let a=await d.z.users.findMany({where:{orgId:this.orgId,isActive:!0,role:{in:["ADMIN","PM","OPERATOR","EDITOR"]}},select:{id:!0,name:!0,email:!0,role:!0}}),b=a.map(a=>a.id),c=await d.z.pipelineItem.groupBy({by:["assignedToId"],where:{assignedToId:{in:b},status:{notIn:["COMPLETED","CANCELLED"]}},_count:{id:!0}}),e=new Map;for(let a of c)a.assignedToId&&e.set(a.assignedToId,a._count.id);return a.map(a=>({userId:a.id,userName:a.name??"Unknown",userEmail:a.email,userRole:a.role,currentLoad:e.get(a.id)??0,maxLoad:20,availableCapacity:20-(e.get(a.id)??0),isAvailable:!0,lastAssignedAt:void 0}))}workloadInfoToUserSummary(a){return{id:a.userId,name:a.userName,email:a.userEmail,role:a.userRole,currentLoad:a.currentLoad,maxLoad:a.maxLoad,isAvailable:a.isAvailable}}async fetchIntakeRequest(a){let b=await d.z.intakeRequest.findUnique({where:{id:a},include:{pipeline:{include:{stages:{orderBy:{order:"asc"}}}}}});if(!b)throw new g("intake",a);if(b.orgId!==this.orgId)throw new h("Intake does not belong to this organization",a,{intakeOrgId:b.orgId,requestedOrgId:this.orgId});return b}async fetchPipelineItemByIntakeId(a){let b=await d.z.pipelineItem.findUnique({where:{id:a},include:{stage:!0}});if(b)return b;let c=await d.z.pipelineItem.findMany({where:{data:{path:["intakeRequestId"],equals:a}},include:{stage:!0},take:1});return c.length>0?c[0]:null}async fetchPipeline(a){let b=await d.z.pipeline.findUnique({where:{id:a},include:{stages:{orderBy:{order:"asc"}}}});if(!b)throw new g("pipeline",a);return b}validateIntakeNotClosed(a){if(["COMPLETED","REJECTED"].includes(a.status.toUpperCase()))throw new i(`Cannot modify intake with status "${a.status}"`,a.id,{status:a.status})}validatePipelineActive(a){if(!a.isActive)throw new f("Cannot assign to inactive pipeline",void 0,{pipelineId:a.id,pipelineName:a.name})}validateStageInPipeline(a,b){if(!b.stages.some(b=>b.id===a))throw new f("Stage does not belong to the specified pipeline",void 0,{stageId:a,pipelineId:b.id,availableStages:b.stages.map(a=>a.id)})}async validateUserExists(a){if(!await d.z.users.findUnique({where:{id:a},select:{id:!0}}))throw new g("user",a)}getDefaultStage(a){return a.stages[0]}captureIntakeState(a){return{pipelineId:a.assignedPipeline,pipelineName:a.pipeline?.name,stageId:null,stageName:void 0,assigneeId:null,assigneeName:void 0,priority:a.priority,tags:[],status:a.status}}capturePipelineItemState(a,b){return{pipelineId:null,pipelineName:void 0,stageId:a.stageId,stageName:b??a.stage?.name,assigneeId:a.assignedToId,assigneeName:void 0,priority:a.priority,tags:a.tags||[],status:a.status}}async createAuditLog(a){try{let b=await d.z.activityLog.create({data:{id:function(){let a=Date.now().toString(36),b=Math.random().toString(36).substring(2,15);return`${a}${b}`}(),orgId:this.orgId,userId:this.isAgentAction?this.agentId:this.userId,action:a.action,entity:a.entityType,entityId:a.entityId,changes:{previousState:a.previousState,newState:a.newState,reason:a.reason},metadata:{...a.metadata??{},performedByType:this.isAgentAction?"agent":"human",agentId:this.agentId}}});return this.logger.debug("Audit log created",{auditLogId:b.id,action:a.action,entityId:a.entityId}),b.id}catch(b){this.logger.error("Failed to create audit log",b,{entityId:a.entityId,action:a.action});return}}handleError(a,b,c){let d=b instanceof Error?b.message:"Unknown error occurred";return this.logger.error(`Failed to ${c} intake`,b,{intakeId:a}),{success:!1,intakeId:a,previousState:{pipelineId:null,stageId:null,assigneeId:null,priority:0,tags:[],status:"unknown"},newState:{pipelineId:null,stageId:null,assigneeId:null,priority:0,tags:[],status:"error"},error:d,timestamp:new Date}}updateConfig(a){void 0!==a.agentId&&(this.agentId=a.agentId),void 0!==a.userId&&(this.userId=a.userId),void 0!==a.isAgentAction&&(this.isAgentAction=a.isAgentAction),void 0!==a.debug&&(this.debug=a.debug),this.logger.debug("Configuration updated",a)}async getPipelineSummaries(){return(await d.z.pipeline.findMany({where:{isActive:!0},include:{stages:{orderBy:{order:"asc"}}}})).map(a=>({id:a.id,name:a.name,stages:a.stages.map(a=>a.name),category:"general",description:a.description??void 0,isActive:a.isActive}))}}}};