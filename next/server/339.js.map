{"version":3,"file":"339.js","mappings":"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Cc,OAAZA,GACmB,UAAnB,OAAOA,GACP,SAAUA,GACc,YAAxB,OAAOA,EAAQC,IAAI,iDCJhB,SAAShB,EAAcG,CAAY,CAAED,CAAc,EACxD,GAAI,UAA0B,OAAnBC,EACT,OAAO,EAGT,GAAM,UAAE1B,CAAQ,CAAE,CAAGwC,CAAAA,EAAAA,EAAAA,CAAAA,CAASA,CAACd,GAC/B,OAAO1B,IAAayB,GAAUzB,EAAS4B,UAAU,CAACH,EAAS,IAC7D,mCEfA,qCAA6C,CAC7C,QACA,CAAC,EAAC,CAKF,cACA,0CACA,cACA,SACK,CACL,EACA,GACA,0BACA,QACA,CAAK,CACL,uBACA,QACA,CACA,CAAC,EAED,UADyB,EAAQ,KAAkB,EACnD,UADgC,OAChC,CACA,gBACA,yCACA,MACA,OAEA,eAGA,OACA,MACA,UAJA,UAKA,SAJA,gCAKA,CACA,CACA,kBACA,oBACA,EAGA,WAFA,GAGA,CACA,gBACA,0BACA,IAGA,KACA,cAGA,2DC7CA,MAAe,mBACf,IAAY,QAAU,SAAQ,EAAI,CAVlC,KACA,kCACA,kBACA,4BACA,YACA,8BACA,aACA,+CACA,IAGA,0CACA,YACA,YAAqB,YAAiB,EACtC,OACA,MACA,CAAK,2DACL,CAAC,CCLD,CDKE,QCLF,OACA,sBACA,mCACA,8BACA,oBAAgC,EAAM,mDACtC,QACA,CAwBA,eAAe,EAAI,WACnB,OAAW,EA1CX,EA0CiB,OA1CjB,GACA,UACA,aACA,aACA,aACA,WACA,QACA,SACA,6CACA,CACA,EAgCiB,GAxBjB,YACA,iBACA,iBACA,6DACA,QACA,EAmBiB,eAlBjB,YACA,kBACA,qBACA,gEAEA,QACA,EAYiB,GAXjB,cACA,iDACA,uDAGA,SADA,kCAEA,sCAEA,QACA,EAEiB,KACjB,mCChBO,SACP,WACA,iBACA,uGACA,aACA,cACA,eACA,CAAa,EAEb,wCACA,gBACA,CACA,gBACA,iBACA,wGACA,aACA,cACA,eACA,CAAa,CAEb,mBACA,8CAEA,gBACA,CACA,cACA,4BACA,iBACA,gBACA,CACA,kBCzDA,qCAA6C,CAC7C,QACA,CAA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","sources":["webpack://_N_E/../../../../src/shared/lib/router/utils/relativize-url.ts","webpack://_N_E/../../../../src/shared/lib/lazy-dynamic/bailout-to-csr.ts","webpack://_N_E/../../../../src/shared/lib/i18n/normalize-locale-path.ts","webpack://_N_E/../../../../src/shared/lib/router/utils/remove-path-prefix.ts","webpack://_N_E/../../../../src/shared/lib/router/utils/get-next-pathname-info.ts","webpack://_N_E/../../../src/shared/lib/is-thenable.ts","webpack://_N_E/../../../../src/shared/lib/router/utils/path-has-prefix.ts","webpack://_N_E/../../../src/shared/lib/invariant-error.ts","webpack://_N_E/./node_modules/next/dist/experimental/testmode/context.js","webpack://_N_E/./node_modules/@panva/hkdf/dist/web/runtime/hkdf.js","webpack://_N_E/./node_modules/@panva/hkdf/dist/web/index.js","webpack://_N_E/./node_modules/next/dist/esm/server/web/web-on-close.js","webpack://_N_E/./node_modules/next/dist/experimental/testmode/server-edge.js","webpack://_N_E/../../../../src/shared/lib/i18n/detect-domain-locale.ts","webpack://_N_E/../../../../src/shared/lib/page-path/ensure-leading-slash.ts","webpack://_N_E/../../../src/shared/lib/segment.ts","webpack://_N_E/../../../../src/shared/lib/router/utils/app-paths.ts","webpack://_N_E/../../../src/shared/lib/get-hostname.ts","webpack://_N_E/../../../../src/shared/lib/router/utils/remove-trailing-slash.ts","webpack://_N_E/../../../../src/shared/lib/router/utils/add-path-prefix.ts","webpack://_N_E/../../../../src/shared/lib/router/utils/add-path-suffix.ts","webpack://_N_E/../../../../src/shared/lib/router/utils/add-locale.ts","webpack://_N_E/../../../../src/shared/lib/router/utils/format-next-pathname-info.ts","webpack://_N_E/./node_modules/next/dist/experimental/testmode/fetch.js","webpack://_N_E/../../../../src/shared/lib/utils/reflect-utils.ts","webpack://_N_E/../../../../src/shared/lib/router/utils/parse-path.ts"],"sourcesContent":["/**\n * The result of parsing a URL relative to a base URL.\n */\nexport type RelativeURL = {\n  /**\n   * The relative URL. Either a URL including the origin or a relative URL.\n   */\n  url: string\n\n  /**\n   * Whether the URL is relative to the base URL.\n   */\n  isRelative: boolean\n}\n\nexport function parseRelativeURL(\n  url: string | URL,\n  base: string | URL\n): RelativeURL {\n  const baseURL = typeof base === 'string' ? new URL(base) : base\n  const relative = new URL(url, base)\n\n  // The URL is relative if the origin is the same as the base URL.\n  const isRelative = relative.origin === baseURL.origin\n\n  return {\n    url: isRelative\n      ? relative.toString().slice(baseURL.origin.length)\n      : relative.toString(),\n    isRelative,\n  }\n}\n\n/**\n * Given a URL as a string and a base URL it will make the URL relative\n * if the parsed protocol and host is the same as the one in the base\n * URL. Otherwise it returns the same URL string.\n */\nexport function getRelativeURL(url: string | URL, base: string | URL): string {\n  const relative = parseRelativeURL(url, base)\n  return relative.url\n}\n","// This has to be a shared module which is shared between client component error boundary and dynamic component\nconst BAILOUT_TO_CSR = 'BAILOUT_TO_CLIENT_SIDE_RENDERING'\n\n/** An error that should be thrown when we want to bail out to client-side rendering. */\nexport class BailoutToCSRError extends Error {\n  public readonly digest = BAILOUT_TO_CSR\n\n  constructor(public readonly reason: string) {\n    super(`Bail out to client-side rendering: ${reason}`)\n  }\n}\n\n/** Checks if a passed argument is an error that is thrown if we want to bail out to client-side rendering. */\nexport function isBailoutToCSRError(err: unknown): err is BailoutToCSRError {\n  if (typeof err !== 'object' || err === null || !('digest' in err)) {\n    return false\n  }\n\n  return err.digest === BAILOUT_TO_CSR\n}\n","export interface PathLocale {\n  detectedLocale?: string\n  pathname: string\n}\n\n/**\n * A cache of lowercased locales for each list of locales. This is stored as a\n * WeakMap so if the locales are garbage collected, the cache entry will be\n * removed as well.\n */\nconst cache = new WeakMap<readonly string[], readonly string[]>()\n\n/**\n * For a pathname that may include a locale from a list of locales, it\n * removes the locale from the pathname returning it alongside with the\n * detected locale.\n *\n * @param pathname A pathname that may include a locale.\n * @param locales A list of locales.\n * @returns The detected locale and pathname without locale\n */\nexport function normalizeLocalePath(\n  pathname: string,\n  locales?: readonly string[]\n): PathLocale {\n  // If locales is undefined, return the pathname as is.\n  if (!locales) return { pathname }\n\n  // Get the cached lowercased locales or create a new cache entry.\n  let lowercasedLocales = cache.get(locales)\n  if (!lowercasedLocales) {\n    lowercasedLocales = locales.map((locale) => locale.toLowerCase())\n    cache.set(locales, lowercasedLocales)\n  }\n\n  let detectedLocale: string | undefined\n\n  // The first segment will be empty, because it has a leading `/`. If\n  // there is no further segment, there is no locale (or it's the default).\n  const segments = pathname.split('/', 2)\n\n  // If there's no second segment (ie, the pathname is just `/`), there's no\n  // locale.\n  if (!segments[1]) return { pathname }\n\n  // The second segment will contain the locale part if any.\n  const segment = segments[1].toLowerCase()\n\n  // See if the segment matches one of the locales. If it doesn't, there is\n  // no locale (or it's the default).\n  const index = lowercasedLocales.indexOf(segment)\n  if (index < 0) return { pathname }\n\n  // Return the case-sensitive locale.\n  detectedLocale = locales[index]\n\n  // Remove the `/${locale}` part of the pathname.\n  pathname = pathname.slice(detectedLocale.length + 1) || '/'\n\n  return { pathname, detectedLocale }\n}\n","import { pathHasPrefix } from './path-has-prefix'\n\n/**\n * Given a path and a prefix it will remove the prefix when it exists in the\n * given path. It ensures it matches exactly without containing extra chars\n * and if the prefix is not there it will be noop.\n *\n * @param path The path to remove the prefix from.\n * @param prefix The prefix to be removed.\n */\nexport function removePathPrefix(path: string, prefix: string): string {\n  // If the path doesn't start with the prefix we can return it as is. This\n  // protects us from situations where the prefix is a substring of the path\n  // prefix such as:\n  //\n  // For prefix: /blog\n  //\n  //   /blog -> true\n  //   /blog/ -> true\n  //   /blog/1 -> true\n  //   /blogging -> false\n  //   /blogging/ -> false\n  //   /blogging/1 -> false\n  if (!pathHasPrefix(path, prefix)) {\n    return path\n  }\n\n  // Remove the prefix from the path via slicing.\n  const withoutPrefix = path.slice(prefix.length)\n\n  // If the path without the prefix starts with a `/` we can return it as is.\n  if (withoutPrefix.startsWith('/')) {\n    return withoutPrefix\n  }\n\n  // If the path without the prefix doesn't start with a `/` we need to add it\n  // back to the path to make sure it's a valid path.\n  return `/${withoutPrefix}`\n}\n","import { normalizeLocalePath } from '../../i18n/normalize-locale-path'\nimport { removePathPrefix } from './remove-path-prefix'\nimport { pathHasPrefix } from './path-has-prefix'\nimport type { I18NProvider } from '../../../../server/lib/i18n-provider'\n\nexport interface NextPathnameInfo {\n  /**\n   * The base path in case the pathname included it.\n   */\n  basePath?: string\n  /**\n   * The buildId for when the parsed URL is a data URL. Parsing it can be\n   * disabled with the `parseData` option.\n   */\n  buildId?: string\n  /**\n   * If there was a locale in the pathname, this will hold its value.\n   */\n  locale?: string\n  /**\n   * The processed pathname without a base path, locale, or data URL elements\n   * when parsing it is enabled.\n   */\n  pathname: string\n  /**\n   * A boolean telling if the pathname had a trailingSlash. This can be only\n   * true if trailingSlash is enabled.\n   */\n  trailingSlash?: boolean\n}\n\ninterface Options {\n  /**\n   * When passed to true, this function will also parse Nextjs data URLs.\n   */\n  parseData?: boolean\n  /**\n   * A partial of the Next.js configuration to parse the URL.\n   */\n  nextConfig?: {\n    basePath?: string\n    i18n?: { locales?: readonly string[] } | null\n    trailingSlash?: boolean\n  }\n\n  /**\n   * If provided, this normalizer will be used to detect the locale instead of\n   * the default locale detection.\n   */\n  i18nProvider?: I18NProvider\n}\n\nexport function getNextPathnameInfo(\n  pathname: string,\n  options: Options\n): NextPathnameInfo {\n  const { basePath, i18n, trailingSlash } = options.nextConfig ?? {}\n  const info: NextPathnameInfo = {\n    pathname,\n    trailingSlash: pathname !== '/' ? pathname.endsWith('/') : trailingSlash,\n  }\n\n  if (basePath && pathHasPrefix(info.pathname, basePath)) {\n    info.pathname = removePathPrefix(info.pathname, basePath)\n    info.basePath = basePath\n  }\n  let pathnameNoDataPrefix = info.pathname\n\n  if (\n    info.pathname.startsWith('/_next/data/') &&\n    info.pathname.endsWith('.json')\n  ) {\n    const paths = info.pathname\n      .replace(/^\\/_next\\/data\\//, '')\n      .replace(/\\.json$/, '')\n      .split('/')\n\n    const buildId = paths[0]\n    info.buildId = buildId\n    pathnameNoDataPrefix =\n      paths[1] !== 'index' ? `/${paths.slice(1).join('/')}` : '/'\n\n    // update pathname with normalized if enabled although\n    // we use normalized to populate locale info still\n    if (options.parseData === true) {\n      info.pathname = pathnameNoDataPrefix\n    }\n  }\n\n  // If provided, use the locale route normalizer to detect the locale instead\n  // of the function below.\n  if (i18n) {\n    let result = options.i18nProvider\n      ? options.i18nProvider.analyze(info.pathname)\n      : normalizeLocalePath(info.pathname, i18n.locales)\n\n    info.locale = result.detectedLocale\n    info.pathname = result.pathname ?? info.pathname\n\n    if (!result.detectedLocale && info.buildId) {\n      result = options.i18nProvider\n        ? options.i18nProvider.analyze(pathnameNoDataPrefix)\n        : normalizeLocalePath(pathnameNoDataPrefix, i18n.locales)\n\n      if (result.detectedLocale) {\n        info.locale = result.detectedLocale\n      }\n    }\n  }\n  return info\n}\n","/**\n * Check to see if a value is Thenable.\n *\n * @param promise the maybe-thenable value\n * @returns true if the value is thenable\n */\nexport function isThenable<T = unknown>(\n  promise: Promise<T> | T\n): promise is Promise<T> {\n  return (\n    promise !== null &&\n    typeof promise === 'object' &&\n    'then' in promise &&\n    typeof promise.then === 'function'\n  )\n}\n","import { parsePath } from './parse-path'\n\n/**\n * Checks if a given path starts with a given prefix. It ensures it matches\n * exactly without containing extra chars. e.g. prefix /docs should replace\n * for /docs, /docs/, /docs/a but not /docsss\n * @param path The path to check.\n * @param prefix The prefix to check against.\n */\nexport function pathHasPrefix(path: string, prefix: string) {\n  if (typeof path !== 'string') {\n    return false\n  }\n\n  const { pathname } = parsePath(path)\n  return pathname === prefix || pathname.startsWith(prefix + '/')\n}\n","export class InvariantError extends Error {\n  constructor(message: string, options?: ErrorOptions) {\n    super(\n      `Invariant: ${message.endsWith('.') ? message : message + '.'} This is a bug in Next.js.`,\n      options\n    )\n    this.name = 'InvariantError'\n  }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    getTestReqInfo: null,\n    withRequest: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getTestReqInfo: function() {\n        return getTestReqInfo;\n    },\n    withRequest: function() {\n        return withRequest;\n    }\n});\nconst _nodeasync_hooks = require(\"node:async_hooks\");\nconst testStorage = new _nodeasync_hooks.AsyncLocalStorage();\nfunction extractTestInfoFromRequest(req, reader) {\n    const proxyPortHeader = reader.header(req, 'next-test-proxy-port');\n    if (!proxyPortHeader) {\n        return undefined;\n    }\n    const url = reader.url(req);\n    const proxyPort = Number(proxyPortHeader);\n    const testData = reader.header(req, 'next-test-data') || '';\n    return {\n        url,\n        proxyPort,\n        testData\n    };\n}\nfunction withRequest(req, reader, fn) {\n    const testReqInfo = extractTestInfoFromRequest(req, reader);\n    if (!testReqInfo) {\n        return fn();\n    }\n    return testStorage.run(testReqInfo, fn);\n}\nfunction getTestReqInfo(req, reader) {\n    const testReqInfo = testStorage.getStore();\n    if (testReqInfo) {\n        return testReqInfo;\n    }\n    if (req && reader) {\n        return extractTestInfoFromRequest(req, reader);\n    }\n    return undefined;\n}\n\n//# sourceMappingURL=context.js.map","const getGlobal = () => {\n    if (typeof globalThis !== 'undefined')\n        return globalThis;\n    if (typeof self !== 'undefined')\n        return self;\n    if (typeof window !== 'undefined')\n        return window;\n    throw new Error('unable to locate global object');\n};\nexport default async (digest, ikm, salt, info, keylen) => {\n    const { crypto: { subtle }, } = getGlobal();\n    return new Uint8Array(await subtle.deriveBits({\n        name: 'HKDF',\n        hash: `SHA-${digest.substr(3)}`,\n        salt,\n        info,\n    }, await subtle.importKey('raw', ikm, 'HKDF', false, ['deriveBits']), keylen << 3));\n};\n","import derive from './runtime/hkdf.js';\nfunction normalizeDigest(digest) {\n    switch (digest) {\n        case 'sha256':\n        case 'sha384':\n        case 'sha512':\n        case 'sha1':\n            return digest;\n        default:\n            throw new TypeError('unsupported \"digest\" value');\n    }\n}\nfunction normalizeUint8Array(input, label) {\n    if (typeof input === 'string')\n        return new TextEncoder().encode(input);\n    if (!(input instanceof Uint8Array))\n        throw new TypeError(`\"${label}\"\" must be an instance of Uint8Array or a string`);\n    return input;\n}\nfunction normalizeIkm(input) {\n    const ikm = normalizeUint8Array(input, 'ikm');\n    if (!ikm.byteLength)\n        throw new TypeError(`\"ikm\" must be at least one byte in length`);\n    return ikm;\n}\nfunction normalizeInfo(input) {\n    const info = normalizeUint8Array(input, 'info');\n    if (info.byteLength > 1024) {\n        throw TypeError('\"info\" must not contain more than 1024 bytes');\n    }\n    return info;\n}\nfunction normalizeKeylen(input, digest) {\n    if (typeof input !== 'number' || !Number.isInteger(input) || input < 1) {\n        throw new TypeError('\"keylen\" must be a positive integer');\n    }\n    const hashlen = parseInt(digest.substr(3), 10) >> 3 || 20;\n    if (input > 255 * hashlen) {\n        throw new TypeError('\"keylen\" too large');\n    }\n    return input;\n}\nasync function hkdf(digest, ikm, salt, info, keylen) {\n    return derive(normalizeDigest(digest), normalizeIkm(ikm), normalizeUint8Array(salt, 'salt'), normalizeInfo(info), normalizeKeylen(keylen, digest));\n}\nexport { hkdf, hkdf as default };\n","/** Monitor when the consumer finishes reading the response body.\nthat's as close as we can get to `res.on('close')` using web APIs.\n*/ export function trackBodyConsumed(body, onEnd) {\n    if (typeof body === 'string') {\n        const generator = async function* generate() {\n            const encoder = new TextEncoder();\n            yield encoder.encode(body);\n            onEnd();\n        };\n        // @ts-expect-error BodyInit typings doesn't seem to include AsyncIterables even though it's supported in practice\n        return generator();\n    } else {\n        return trackStreamConsumed(body, onEnd);\n    }\n}\nexport function trackStreamConsumed(stream, onEnd) {\n    // NOTE: This function must handle `stream` being aborted or cancelled,\n    // so it can't just be this:\n    //\n    //   return stream.pipeThrough(new TransformStream({ flush() { onEnd() } }))\n    //\n    // because that doesn't handle cancellations.\n    // (and cancellation handling via `Transformer.cancel` is only available in node >20)\n    const dest = new TransformStream();\n    const runOnEnd = ()=>onEnd();\n    stream.pipeTo(dest.writable).then(runOnEnd, runOnEnd);\n    return dest.readable;\n}\nexport class CloseController {\n    onClose(callback) {\n        if (this.isClosed) {\n            throw Object.defineProperty(new Error('Cannot subscribe to a closed CloseController'), \"__NEXT_ERROR_CODE\", {\n                value: \"E365\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        this.target.addEventListener('close', callback);\n        this.listeners++;\n    }\n    dispatchClose() {\n        if (this.isClosed) {\n            throw Object.defineProperty(new Error('Cannot close a CloseController multiple times'), \"__NEXT_ERROR_CODE\", {\n                value: \"E229\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (this.listeners > 0) {\n            this.target.dispatchEvent(new Event('close'));\n        }\n        this.isClosed = true;\n    }\n    constructor(){\n        this.target = new EventTarget();\n        this.listeners = 0;\n        this.isClosed = false;\n    }\n}\n\n//# sourceMappingURL=web-on-close.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    interceptTestApis: null,\n    wrapRequestHandler: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    interceptTestApis: function() {\n        return interceptTestApis;\n    },\n    wrapRequestHandler: function() {\n        return wrapRequestHandler;\n    }\n});\nconst _context = require(\"./context\");\nconst _fetch = require(\"./fetch\");\nfunction interceptTestApis() {\n    return (0, _fetch.interceptFetch)(global.fetch);\n}\nfunction wrapRequestHandler(handler) {\n    return (req, fn)=>(0, _context.withRequest)(req, _fetch.reader, ()=>handler(req, fn));\n}\n\n//# sourceMappingURL=server-edge.js.map","import type { DomainLocale } from '../../../server/config-shared'\n\nexport function detectDomainLocale(\n  domainItems?: readonly DomainLocale[],\n  hostname?: string,\n  detectedLocale?: string\n) {\n  if (!domainItems) return\n\n  if (detectedLocale) {\n    detectedLocale = detectedLocale.toLowerCase()\n  }\n\n  for (const item of domainItems) {\n    // remove port if present\n    const domainHostname = item.domain?.split(':', 1)[0].toLowerCase()\n    if (\n      hostname === domainHostname ||\n      detectedLocale === item.defaultLocale.toLowerCase() ||\n      item.locales?.some((locale) => locale.toLowerCase() === detectedLocale)\n    ) {\n      return item\n    }\n  }\n}\n","/**\n * For a given page path, this function ensures that there is a leading slash.\n * If there is not a leading slash, one is added, otherwise it is noop.\n */\nexport function ensureLeadingSlash(path: string) {\n  return path.startsWith('/') ? path : `/${path}`\n}\n","import type { Segment } from '../../server/app-render/types'\n\nexport function isGroupSegment(segment: string) {\n  // Use array[0] for performant purpose\n  return segment[0] === '(' && segment.endsWith(')')\n}\n\nexport function isParallelRouteSegment(segment: string) {\n  return segment.startsWith('@') && segment !== '@children'\n}\n\nexport function addSearchParamsIfPageSegment(\n  segment: Segment,\n  searchParams: Record<string, string | string[] | undefined>\n) {\n  const isPageSegment = segment.includes(PAGE_SEGMENT_KEY)\n\n  if (isPageSegment) {\n    const stringifiedQuery = JSON.stringify(searchParams)\n    return stringifiedQuery !== '{}'\n      ? PAGE_SEGMENT_KEY + '?' + stringifiedQuery\n      : PAGE_SEGMENT_KEY\n  }\n\n  return segment\n}\n\nexport const PAGE_SEGMENT_KEY = '__PAGE__'\nexport const DEFAULT_SEGMENT_KEY = '__DEFAULT__'\n","import { ensureLeadingSlash } from '../../page-path/ensure-leading-slash'\nimport { isGroupSegment } from '../../segment'\n\n/**\n * Normalizes an app route so it represents the actual request path. Essentially\n * performing the following transformations:\n *\n * - `/(dashboard)/user/[id]/page` to `/user/[id]`\n * - `/(dashboard)/account/page` to `/account`\n * - `/user/[id]/page` to `/user/[id]`\n * - `/account/page` to `/account`\n * - `/page` to `/`\n * - `/(dashboard)/user/[id]/route` to `/user/[id]`\n * - `/(dashboard)/account/route` to `/account`\n * - `/user/[id]/route` to `/user/[id]`\n * - `/account/route` to `/account`\n * - `/route` to `/`\n * - `/` to `/`\n *\n * @param route the app route to normalize\n * @returns the normalized pathname\n */\nexport function normalizeAppPath(route: string) {\n  return ensureLeadingSlash(\n    route.split('/').reduce((pathname, segment, index, segments) => {\n      // Empty segments are ignored.\n      if (!segment) {\n        return pathname\n      }\n\n      // Groups are ignored.\n      if (isGroupSegment(segment)) {\n        return pathname\n      }\n\n      // Parallel segments are ignored.\n      if (segment[0] === '@') {\n        return pathname\n      }\n\n      // The last segment (if it's a leaf) should be ignored.\n      if (\n        (segment === 'page' || segment === 'route') &&\n        index === segments.length - 1\n      ) {\n        return pathname\n      }\n\n      return `${pathname}/${segment}`\n    }, '')\n  )\n}\n\n/**\n * Strips the `.rsc` extension if it's in the pathname.\n * Since this function is used on full urls it checks `?` for searchParams handling.\n */\nexport function normalizeRscURL(url: string) {\n  return url.replace(\n    /\\.rsc($|\\?)/,\n    // $1 ensures `?` is preserved\n    '$1'\n  )\n}\n","import type { OutgoingHttpHeaders } from 'http'\n\n/**\n * Takes an object with a hostname property (like a parsed URL) and some\n * headers that may contain Host and returns the preferred hostname.\n * @param parsed An object containing a hostname property.\n * @param headers A dictionary with headers containing a `host`.\n */\nexport function getHostname(\n  parsed: { hostname?: string | null },\n  headers?: OutgoingHttpHeaders\n): string | undefined {\n  // Get the hostname from the headers if it exists, otherwise use the parsed\n  // hostname.\n  let hostname: string\n  if (headers?.host && !Array.isArray(headers.host)) {\n    hostname = headers.host.toString().split(':', 1)[0]\n  } else if (parsed.hostname) {\n    hostname = parsed.hostname\n  } else return\n\n  return hostname.toLowerCase()\n}\n","/**\n * Removes the trailing slash for a given route or page path. Preserves the\n * root page. Examples:\n *   - `/foo/bar/` -> `/foo/bar`\n *   - `/foo/bar` -> `/foo/bar`\n *   - `/` -> `/`\n */\nexport function removeTrailingSlash(route: string) {\n  return route.replace(/\\/$/, '') || '/'\n}\n","import { parsePath } from './parse-path'\n\n/**\n * Adds the provided prefix to the given path. It first ensures that the path\n * is indeed starting with a slash.\n */\nexport function addPathPrefix(path: string, prefix?: string) {\n  if (!path.startsWith('/') || !prefix) {\n    return path\n  }\n\n  const { pathname, query, hash } = parsePath(path)\n  return `${prefix}${pathname}${query}${hash}`\n}\n","import { parsePath } from './parse-path'\n\n/**\n * Similarly to `addPathPrefix`, this function adds a suffix at the end on the\n * provided path. It also works only for paths ensuring the argument starts\n * with a slash.\n */\nexport function addPathSuffix(path: string, suffix?: string) {\n  if (!path.startsWith('/') || !suffix) {\n    return path\n  }\n\n  const { pathname, query, hash } = parsePath(path)\n  return `${pathname}${suffix}${query}${hash}`\n}\n","import { addPathPrefix } from './add-path-prefix'\nimport { pathHasPrefix } from './path-has-prefix'\n\n/**\n * For a given path and a locale, if the locale is given, it will prefix the\n * locale. The path shouldn't be an API path. If a default locale is given the\n * prefix will be omitted if the locale is already the default locale.\n */\nexport function addLocale(\n  path: string,\n  locale?: string | false,\n  defaultLocale?: string,\n  ignorePrefix?: boolean\n) {\n  // If no locale was given or the locale is the default locale, we don't need\n  // to prefix the path.\n  if (!locale || locale === defaultLocale) return path\n\n  const lower = path.toLowerCase()\n\n  // If the path is an API path or the path already has the locale prefix, we\n  // don't need to prefix the path.\n  if (!ignorePrefix) {\n    if (pathHasPrefix(lower, '/api')) return path\n    if (pathHasPrefix(lower, `/${locale.toLowerCase()}`)) return path\n  }\n\n  // Add the locale prefix to the path.\n  return addPathPrefix(path, `/${locale}`)\n}\n","import type { NextPathnameInfo } from './get-next-pathname-info'\nimport { removeTrailingSlash } from './remove-trailing-slash'\nimport { addPathPrefix } from './add-path-prefix'\nimport { addPathSuffix } from './add-path-suffix'\nimport { addLocale } from './add-locale'\n\ninterface ExtendedInfo extends NextPathnameInfo {\n  defaultLocale?: string\n  ignorePrefix?: boolean\n}\n\nexport function formatNextPathnameInfo(info: ExtendedInfo) {\n  let pathname = addLocale(\n    info.pathname,\n    info.locale,\n    info.buildId ? undefined : info.defaultLocale,\n    info.ignorePrefix\n  )\n\n  if (info.buildId || !info.trailingSlash) {\n    pathname = removeTrailingSlash(pathname)\n  }\n\n  if (info.buildId) {\n    pathname = addPathSuffix(\n      addPathPrefix(pathname, `/_next/data/${info.buildId}`),\n      info.pathname === '/' ? 'index.json' : '.json'\n    )\n  }\n\n  pathname = addPathPrefix(pathname, info.basePath)\n  return !info.buildId && info.trailingSlash\n    ? !pathname.endsWith('/')\n      ? addPathSuffix(pathname, '/')\n      : pathname\n    : removeTrailingSlash(pathname)\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    handleFetch: null,\n    interceptFetch: null,\n    reader: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    handleFetch: function() {\n        return handleFetch;\n    },\n    interceptFetch: function() {\n        return interceptFetch;\n    },\n    reader: function() {\n        return reader;\n    }\n});\nconst _context = require(\"./context\");\nconst reader = {\n    url (req) {\n        return req.url;\n    },\n    header (req, name) {\n        return req.headers.get(name);\n    }\n};\nfunction getTestStack() {\n    let stack = (new Error().stack ?? '').split('\\n');\n    // Skip the first line and find first non-empty line.\n    for(let i = 1; i < stack.length; i++){\n        if (stack[i].length > 0) {\n            stack = stack.slice(i);\n            break;\n        }\n    }\n    // Filter out franmework lines.\n    stack = stack.filter((f)=>!f.includes('/next/dist/'));\n    // At most 5 lines.\n    stack = stack.slice(0, 5);\n    // Cleanup some internal info and trim.\n    stack = stack.map((s)=>s.replace('webpack-internal:///(rsc)/', '').trim());\n    return stack.join('    ');\n}\nasync function buildProxyRequest(testData, request) {\n    const { url, method, headers, body, cache, credentials, integrity, mode, redirect, referrer, referrerPolicy } = request;\n    return {\n        testData,\n        api: 'fetch',\n        request: {\n            url,\n            method,\n            headers: [\n                ...Array.from(headers),\n                [\n                    'next-test-stack',\n                    getTestStack()\n                ]\n            ],\n            body: body ? Buffer.from(await request.arrayBuffer()).toString('base64') : null,\n            cache,\n            credentials,\n            integrity,\n            mode,\n            redirect,\n            referrer,\n            referrerPolicy\n        }\n    };\n}\nfunction buildResponse(proxyResponse) {\n    const { status, headers, body } = proxyResponse.response;\n    return new Response(body ? Buffer.from(body, 'base64') : null, {\n        status,\n        headers: new Headers(headers)\n    });\n}\nasync function handleFetch(originalFetch, request) {\n    const testInfo = (0, _context.getTestReqInfo)(request, reader);\n    if (!testInfo) {\n        // Passthrough non-test requests.\n        return originalFetch(request);\n    }\n    const { testData, proxyPort } = testInfo;\n    const proxyRequest = await buildProxyRequest(testData, request);\n    const resp = await originalFetch(`http://localhost:${proxyPort}`, {\n        method: 'POST',\n        body: JSON.stringify(proxyRequest),\n        next: {\n            // @ts-ignore\n            internal: true\n        }\n    });\n    if (!resp.ok) {\n        throw Object.defineProperty(new Error(`Proxy request failed: ${resp.status}`), \"__NEXT_ERROR_CODE\", {\n            value: \"E146\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const proxyResponse = await resp.json();\n    const { api } = proxyResponse;\n    switch(api){\n        case 'continue':\n            return originalFetch(request);\n        case 'abort':\n        case 'unhandled':\n            throw Object.defineProperty(new Error(`Proxy request aborted [${request.method} ${request.url}]`), \"__NEXT_ERROR_CODE\", {\n                value: \"E145\",\n                enumerable: false,\n                configurable: true\n            });\n        case 'fetch':\n            return buildResponse(proxyResponse);\n        default:\n            return api;\n    }\n}\nfunction interceptFetch(originalFetch) {\n    global.fetch = function testFetch(input, init) {\n        var _init_next;\n        // Passthrough internal requests.\n        // @ts-ignore\n        if (init == null ? void 0 : (_init_next = init.next) == null ? void 0 : _init_next.internal) {\n            return originalFetch(input, init);\n        }\n        return handleFetch(originalFetch, new Request(input, init));\n    };\n    return ()=>{\n        global.fetch = originalFetch;\n    };\n}\n\n//# sourceMappingURL=fetch.js.map","// This regex will have fast negatives meaning valid identifiers may not pass\n// this test. However this is only used during static generation to provide hints\n// about why a page bailed out of some or all prerendering and we can use bracket notation\n// for example while `ಠ_ಠ` is a valid identifier it's ok to print `searchParams['ಠ_ಠ']`\n// even if this would have been fine too `searchParams.ಠ_ಠ`\nconst isDefinitelyAValidIdentifier = /^[A-Za-z_$][A-Za-z0-9_$]*$/\n\nexport function describeStringPropertyAccess(target: string, prop: string) {\n  if (isDefinitelyAValidIdentifier.test(prop)) {\n    return `\\`${target}.${prop}\\``\n  }\n  return `\\`${target}[${JSON.stringify(prop)}]\\``\n}\n\nexport function describeHasCheckingStringProperty(\n  target: string,\n  prop: string\n) {\n  const stringifiedProp = JSON.stringify(prop)\n  return `\\`Reflect.has(${target}, ${stringifiedProp})\\`, \\`${stringifiedProp} in ${target}\\`, or similar`\n}\n\nexport const wellKnownProperties = new Set([\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toString',\n  'valueOf',\n  'toLocaleString',\n\n  // Promise prototype\n  // fallthrough\n  'then',\n  'catch',\n  'finally',\n\n  // React Promise extension\n  // fallthrough\n  'status',\n\n  // React introspection\n  'displayName',\n  '_debugInfo',\n\n  // Common tested properties\n  // fallthrough\n  'toJSON',\n  '$$typeof',\n  '__esModule',\n])\n","/**\n * Given a path this function will find the pathname, query and hash and return\n * them. This is useful to parse full paths on the client side.\n * @param path A path to parse e.g. /foo/bar?id=1#hash\n */\nexport function parsePath(path: string) {\n  const hashIndex = path.indexOf('#')\n  const queryIndex = path.indexOf('?')\n  const hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex)\n\n  if (hasQuery || hashIndex > -1) {\n    return {\n      pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),\n      query: hasQuery\n        ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : undefined)\n        : '',\n      hash: hashIndex > -1 ? path.slice(hashIndex) : '',\n    }\n  }\n\n  return { pathname: path, query: '', hash: '' }\n}\n"],"names":["parseRelativeURL","url","base","baseURL","URL","relative","isRelative","origin","toString","slice","length","getRelativeURL","cache","WeakMap","normalizeLocalePath","pathname","locales","detectedLocale","lowercasedLocales","get","map","locale","toLowerCase","set","segments","split","segment","index","indexOf","getNextPathnameInfo","options","result","basePath","i18n","trailingSlash","nextConfig","info","endsWith","pathHasPrefix","removePathPrefix","prefix","path","withoutPrefix","startsWith","pathnameNoDataPrefix","paths","replace","buildId","join","parseData","i18nProvider","analyze","isThenable","promise","then","parsePath","detectDomainLocale","domainItems","hostname","item","domainHostname","domain","defaultLocale","some","normalizeAppPath","route","ensureLeadingSlash","reduce","isGroupSegment","normalizeRscURL","getHostname","parsed","headers","host","Array","isArray","removeTrailingSlash","addPathPrefix","query","hash","addPathSuffix","suffix","formatNextPathnameInfo","addLocale","ignorePrefix","lower","undefined","isDefinitelyAValidIdentifier","describeStringPropertyAccess","target","prop","test","JSON","stringify","wellKnownProperties","Set","hashIndex","queryIndex","hasQuery","substring","InvariantError","Error","constructor","message","name"],"sourceRoot":"","ignoreList":[8,9,10,11,12,23]}